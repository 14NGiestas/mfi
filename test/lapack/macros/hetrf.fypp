#:def hetrf(f77,f90,mfi,pfxs)
#:set wp = pfxs[0]
subroutine test_${f77}$
    use f77_lapack, only: ${f77}$, ${f90}$
    use mfi_lapack, only: ${mfi}$, mfi_${f77}$

    integer, parameter :: wp = ${kind(wp)}$
    integer, parameter :: N = 4
    ${type(wp)}$ :: A(N,N), A_in(N,N), A_rf(N,N)
    ${type(wp)}$ :: A_original(N,N)  ! Store original matrix for multiple tests
    integer :: ipiv_in(N), ipiv_rf(N)
    integer :: info, info_rf, info_mfi
    ${type(wp)}$, allocatable :: work(:)
    integer :: lwork

    ! Create a Hermitian matrix for hetrf (complex version)
    ! For simplicity, using a real symmetric matrix (which works for hetrf on real types)
    A = reshape([2.0_wp, -1.0_wp,  0.0_wp,  0.0_wp, &
                -1.0_wp,  2.0_wp, -1.0_wp,  0.0_wp, &
                 0.0_wp, -1.0_wp,  2.0_wp, -1.0_wp, &
                 0.0_wp,  0.0_wp, -1.0_wp,  2.0_wp], [N,N])

    ! Store original matrix for multiple tests
    A_original = A

    ! Test f77 interface
    A_in = A_original

    ! Query optimal workspace size
    allocate(work(1))
    lwork = -1
    call ${f77}$('U', N, A_in, N, ipiv_in, work, lwork, info)
    if (info == 0) then
        lwork = int(real(work(1), wp))
        if (lwork <= 0) lwork = N  ! Provide a reasonable default
        lwork = max(1, lwork)
        deallocate(work)
        allocate(work(lwork))

        ! Perform the factorization
        A_in = A_original  ! Reset input matrix to original
        call ${f77}$('U', N, A_in, N, ipiv_in, work, lwork, info)
        A_rf = A_in
        ipiv_rf = ipiv_in
        info_rf = info
        deallocate(work)

        if (info /= 0) return  ! Skip if factorization failed
    else
        if (allocated(work)) deallocate(work)
        return  ! Skip if workspace query failed
    end if

    ! Test mfi interface (short form) - includes uplo and ipiv parameters
    A_in = A_original  ! Reset to original matrix
    ipiv_in = 0  ! Initialize pivot array
    call mfi_${f77}$(A_in, 'U', ipiv_in, info=info_mfi)
    ! Compare info, pivots and factorized matrices for hetrf implementations
    call assert(info_mfi == info_rf .and. all(abs(A_in - A_rf) < sqrt(epsilon(1.0_wp))) .and. all(ipiv_in == ipiv_rf), &
                "different results for mfi_${f77}$")

    ! Test mfi interface (full form) - includes uplo and ipiv parameters
    A_in = A_original  ! Reset to original matrix
    ipiv_in = 0  ! Initialize pivot array
    call ${mfi}$(A_in, 'U', ipiv_in, info=info_mfi)
    ! Compare info, pivots and factorized matrices for hetrf implementations
    call assert(info_mfi == info_rf .and. all(abs(A_in - A_rf) < sqrt(epsilon(1.0_wp))) .and. all(ipiv_in == ipiv_rf), &
                "different results for ${mfi}$")

end subroutine
#:enddef
