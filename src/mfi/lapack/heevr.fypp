#:def heevr(MFI_NAME,F77_NAME,pfxs)
#:set wp = pfxs[0]
!> Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix using RRR
pure subroutine ${MFI_NAME}$(a, w, jobz, uplo, range, vl, vu, il, iu, abstol, m, z, isuppz, info)
@:parameter(integer, wp=${kind(wp)}$)
@:args(${type(wp)}$,      inout, a(:,:))
@:args(${real(wp)}$, out, w(:))
    ${type(wp)}$,      intent(out), optional, target :: z(:,:)
    integer,           intent(out), optional, target :: isuppz(:)
    integer,           intent(out), optional :: m
@:optional(character, in, jobz, uplo, range)
@:optional(${real(wp)}$, in,    vl, vu, abstol)
@:optional(integer, in,    il, iu)
@:optional(integer, out,   info)
    ${type(wp)}$,      pointer :: work(:), local_z(:,:)
    ${real(wp)}$,      pointer :: rwork(:)
    integer,           pointer :: iwork(:), local_isuppz(:)
    ${type(wp)}$      :: s_work(1)
    ${real(wp)}$ :: s_rwork(1)
    integer       :: s_iwork(1)
    integer :: n, lda, ldz, lwork, lrwork, liwork, allocation_status, deallocation_status
    integer :: local_m
    ${type(wp)}$, target :: l_z(1,1)
    integer, target :: l_isuppz(2*size(a,1))  ! Default size for isuppz when not present
@:defaults(jobz='N', uplo='U', range='A', vl=0.0_wp, vu=0.0_wp, &
           il=1, iu=size(a,1), abstol=0.0_wp)
    lda = max(1,size(a,1))
    n   = size(a,2)
    ldz = max(1,size(a,1))  ! Size for eigenvector matrix
    if (present(z)) ldz = max(1,size(z,1))
    allocation_status = 0
    lwork  = -1
    lrwork = -1
    liwork = -1
    
    ! Set up pointers
    if (present(z)) then
        local_z => z
    else
        local_z => l_z
    end if
    
    if (present(isuppz)) then
        local_isuppz => isuppz
    else
        local_isuppz => l_isuppz
    end if

    ! Query workspace size
    call ${F77_NAME}$(local_jobz, local_range, local_uplo, n, a, lda, &
                      local_vl, local_vu, local_il, local_iu, local_abstol, &
                      local_m, w, local_z, ldz, local_isuppz, s_work, lwork, s_rwork, lrwork, &
                      s_iwork, liwork, local_info)
    if (local_info /= 0) goto 404
    
    lwork  = int(s_work(1))
    lrwork = int(s_rwork(1))
    liwork = int(s_iwork(1))

    allocate(iwork(liwork), stat=allocation_status)
    if (allocation_status == 0) then
        allocate(rwork(lrwork), stat=allocation_status)
        if (allocation_status == 0) then
            allocate(work(lwork), stat=allocation_status)
            if (allocation_status == 0) then
                ! Call the actual routine
                call ${F77_NAME}$(local_jobz, local_range, local_uplo, n, a, lda, &
                              local_vl, local_vu, local_il, local_iu, local_abstol, &
                              local_m, w, local_z, ldz, local_isuppz, work, lwork, rwork, lrwork, &
                              iwork, liwork, local_info)
                
                ! Copy results if needed
                if (present(m)) m = local_m
            else
                local_info = -1000
            end if
        else
            local_info = -1000
        end if
        deallocate(work, stat=deallocation_status)
    end if
    deallocate(rwork, stat=deallocation_status)
    deallocate(iwork, stat=deallocation_status)
404 continue
    if (present(info)) then
        info = local_info
    else if (local_info <= -1000) then
        call mfi_error('${F77_NAME}$', -local_info)
    end if
end subroutine
#:enddef
