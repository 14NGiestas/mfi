#:def hetrf(MFI_NAME,F77_NAME,pfxs)
#:set wp = pfxs[0]
!> Computes the factorization of a Hermitian matrix using the Bunch-Kaufman diagonal pivoting method
!>
!> The factorization has the form:
!> - A = U*D*U**H (if uplo='U') or
!> - A = L*D*L**H (if uplo='L')
!>
!> where U (or L) is a product of permutation and unit upper (lower) triangular matrices,
!> and D is block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
!>
!> Parameters:
!> - `a` (inout): On entry, the Hermitian matrix A. On exit, the block diagonal matrix D
!>                and the multipliers used to obtain the factor U or L.
!> - `uplo` (in, optional): Specifies whether the upper ('U') or lower ('L') triangular part
!>                of the Hermitian matrix A is stored. Default: 'U'
!> - `ipiv` (out, optional): The pivot indices that define the permutation matrix P.
!>                If ipiv is not provided, it will be allocated internally.
!> - `info` (out, optional): Output status: 0 for success, < 0 for illegal argument,
!>                > 0 if D(k,k) is exactly zero.
pure subroutine ${MFI_NAME}$(a, uplo, ipiv, info)
@:parameter(integer, wp=${kind(wp)}$)
@:args(${type(wp)}$,      inout, a(:,:))
@:optional(character,     in,    uplo)
    integer, intent(out), optional, target :: ipiv(:)
@:optional(integer, out, info)
    integer :: n, lda, lwork, allocation_status, deallocation_status
    integer, pointer :: local_ipiv(:)
    ${type(wp)}$, pointer :: work(:)
    ${type(wp)}$ :: s_work(1)  ! Work array for workspace query
@:defaults(uplo='U')
    lda = max(1,size(a,1))
    n = size(a,2)
    allocation_status = 0

    if (present(ipiv)) then
        local_ipiv => ipiv
    else
        allocate(local_ipiv(n), stat=allocation_status)
    end if

    ! Retrieve work array size
    lwork = -1
    call ${F77_NAME}$(local_uplo, n, a, lda, local_ipiv, s_work, lwork, local_info)
    if (local_info /= 0) goto 404

    lwork = int(s_work(1))
    if (allocation_status == 0) then
        allocate(work(lwork), stat=allocation_status)
    end if
    if (allocation_status == 0) then
        call ${F77_NAME}$(local_uplo, n, a, lda, local_ipiv, work, lwork, local_info)
    else
        local_info = -1000
    end if
    deallocate(work, stat=deallocation_status)

    ! Error handling
404 continue
    if (.not. present(ipiv)) then
        deallocate(local_ipiv, stat=deallocation_status)
    end if
    if (present(info)) then
        info = local_info
    else if (local_info <= -1000) then
        call mfi_error('${F77_NAME}$', -local_info)
    end if

    if (present(info)) then
        info = local_info
    else if (local_info /= 0) then
        if (local_info <= -1000) then
            call mfi_error('${F77_NAME}$', -local_info)
        else
            call mfi_error('${F77_NAME}$', local_info)
        end if
    end if
end subroutine
#:enddef
