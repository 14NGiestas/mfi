#:mute

!subroutine ?pocon (
!   character                      uplo,
!   integer                           n,
!   type(wp), dimension( lda, * )     a,
!   integer                         lda,
!   real(wp)                      anorm,
!   real(wp)                      rcond,
!   type(wp),    dimension( * )    work,
! if REAL_TYPES then,
!   integer,      dimension( * )   iwork,
! if COMPLEX_TYPES then,
!   real(wp),     dimension( * )   rwork,
!   integer                        info 
!)
#:def pocon(NAME, TYPE, KIND)
#:set TYPE_AND_KIND = TYPE.replace('wp',KIND)
#:set PREFIX        = TYPE_AND_KIND_TO_PREFIX.get(TYPE_AND_KIND).upper()
!> ${NAME}$ estimates the reciprocal of the condition number (in the
!> 1-norm) of a ${TYPE_AND_KIND}$ Hermitian positive definite matrix using the
!> Cholesky factorization A = U**H*U or A = L*L**H computed by ${PREFIX}$POTRF.
!> An estimate is obtained for norm(inv(A)), and the reciprocal of the
!> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#:if TYPE == REAL_TYPE
pure subroutine ${NAME}$(uplo, n, a, lda, anorm, rcond, work, iwork, info)
#:elif TYPE == COMPLEX_TYPE
pure subroutine ${NAME}$(uplo, n, a, lda, anorm, rcond, work, rwork, info)
#:endif
    import :: ${KIND}$
@:parameter(integer, wp=${KIND}$)
@:args(character,     in,    uplo)
@:args(integer,       in,    n, lda)
@:args(${TYPE}$,      inout, a(lda,*))
@:args(${REAL_TYPE}$, in,    anorm)
@:args(${REAL_TYPE}$, out,   rcond)
@:args(${TYPE}$,      inout, work(*))
#:if TYPE == REAL_TYPE
@:args(integer,       inout, iwork(*))
#:elif TYPE == COMPLEX_TYPE
@:args(${REAL_TYPE}$, inout, rwork(*))
#:endif
@:args(integer,       out,   info)
end subroutine
#:enddef

#:endmute
