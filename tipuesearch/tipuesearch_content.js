var tipuesearch = {"pages":[{"title":" MFI - Modern Fortran Interfaces ","text":"MFI - Modern Fortran Interfaces Developer Info I. G. Pauli","tags":"home","loc":"index.html"},{"title":"sgeqrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgeqrf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: tau (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/sgeqrf.html"},{"title":"dgeqrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgeqrf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: tau (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/dgeqrf.html"},{"title":"cgeqrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgeqrf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(out) :: tau (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/cgeqrf.html"},{"title":"zgeqrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgeqrf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(out) :: tau (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/zgeqrf.html"},{"title":"f77_geqrf – MFI - Modern Fortran Interfaces","text":"public interface f77_geqrf Module Procedures public  interface sgeqrf () Arguments None public  interface dgeqrf () Arguments None public  interface cgeqrf () Arguments None public  interface zgeqrf () Arguments None","tags":"","loc":"interface/f77_geqrf.html"},{"title":"sgerqf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgerqf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: tau (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/sgerqf.html"},{"title":"dgerqf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgerqf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: tau (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/dgerqf.html"},{"title":"cgerqf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgerqf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(out) :: tau (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/cgerqf.html"},{"title":"zgerqf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgerqf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(out) :: tau (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/zgerqf.html"},{"title":"f77_gerqf – MFI - Modern Fortran Interfaces","text":"public interface f77_gerqf Module Procedures public  interface sgerqf () Arguments None public  interface dgerqf () Arguments None public  interface cgerqf () Arguments None public  interface zgerqf () Arguments None","tags":"","loc":"interface/f77_gerqf.html"},{"title":"sgetrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgetrf(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) integer, intent(out) :: info","tags":"","loc":"interface/sgetrf.html"},{"title":"dgetrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgetrf(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) integer, intent(out) :: info","tags":"","loc":"interface/dgetrf.html"},{"title":"cgetrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgetrf(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) integer, intent(out) :: info","tags":"","loc":"interface/cgetrf.html"},{"title":"zgetrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgetrf(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) integer, intent(out) :: info","tags":"","loc":"interface/zgetrf.html"},{"title":"f77_getrf – MFI - Modern Fortran Interfaces","text":"public interface f77_getrf Module Procedures public  interface sgetrf () Arguments None public  interface dgetrf () Arguments None public  interface cgetrf () Arguments None public  interface zgetrf () Arguments None","tags":"","loc":"interface/f77_getrf.html"},{"title":"sgetri – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgetri(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/sgetri.html"},{"title":"dgetri – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgetri(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/dgetri.html"},{"title":"cgetri – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgetri(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/cgetri.html"},{"title":"zgetri – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgetri(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/zgetri.html"},{"title":"f77_getri – MFI - Modern Fortran Interfaces","text":"public interface f77_getri Module Procedures public  interface sgetri () Arguments None public  interface dgetri () Arguments None public  interface cgetri () Arguments None public  interface zgetri () Arguments None","tags":"","loc":"interface/f77_getri.html"},{"title":"sgetrs – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: nrhs real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","loc":"interface/sgetrs.html"},{"title":"dgetrs – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: nrhs real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","loc":"interface/dgetrs.html"},{"title":"cgetrs – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","loc":"interface/cgetrs.html"},{"title":"zgetrs – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","loc":"interface/zgetrs.html"},{"title":"f77_getrs – MFI - Modern Fortran Interfaces","text":"public interface f77_getrs Module Procedures public  interface sgetrs () Arguments None public  interface dgetrs () Arguments None public  interface cgetrs () Arguments None public  interface zgetrs () Arguments None","tags":"","loc":"interface/f77_getrs.html"},{"title":"chetrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine chetrf(uplo, n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/chetrf.html"},{"title":"zhetrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zhetrf(uplo, n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/zhetrf.html"},{"title":"f77_hetrf – MFI - Modern Fortran Interfaces","text":"public interface f77_hetrf Module Procedures public  interface chetrf () Arguments None public  interface zhetrf () Arguments None","tags":"","loc":"interface/f77_hetrf.html"},{"title":"chegv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine chegv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: itype character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(in) :: rwork (*) integer, intent(out) :: info","tags":"","loc":"interface/chegv.html"},{"title":"zhegv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zhegv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: itype character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(in) :: rwork (*) integer, intent(out) :: info","tags":"","loc":"interface/zhegv.html"},{"title":"f77_hegv – MFI - Modern Fortran Interfaces","text":"public interface f77_hegv Module Procedures public  interface chegv () Arguments None public  interface zhegv () Arguments None","tags":"","loc":"interface/f77_hegv.html"},{"title":"cheevd – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cheevd(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info","tags":"","loc":"interface/cheevd.html"},{"title":"zheevd – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zheevd(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info","tags":"","loc":"interface/zheevd.html"},{"title":"f77_heevd – MFI - Modern Fortran Interfaces","text":"public interface f77_heevd Module Procedures public  interface cheevd () Arguments None public  interface zheevd () Arguments None","tags":"","loc":"interface/f77_heevd.html"},{"title":"cheevx – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cheevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, ifail, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: range character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: vl real(kind=wp), intent(in) :: vu integer, intent(in) :: il integer, intent(in) :: iu real(kind=wp), intent(in) :: abstol integer, intent(in) :: m real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: z (ldz,*) integer, intent(in) :: ldz complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(in) :: ifail integer, intent(out) :: info","tags":"","loc":"interface/cheevx.html"},{"title":"zheevx – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zheevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, ifail, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: range character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: vl real(kind=wp), intent(in) :: vu integer, intent(in) :: il integer, intent(in) :: iu real(kind=wp), intent(in) :: abstol integer, intent(in) :: m real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: z (ldz,*) integer, intent(in) :: ldz complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(in) :: ifail integer, intent(out) :: info","tags":"","loc":"interface/zheevx.html"},{"title":"f77_heevx – MFI - Modern Fortran Interfaces","text":"public interface f77_heevx Module Procedures public  interface cheevx () Arguments None public  interface zheevx () Arguments None","tags":"","loc":"interface/f77_heevx.html"},{"title":"cheevr – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cheevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: range character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: vl real(kind=wp), intent(in) :: vu integer, intent(in) :: il integer, intent(in) :: iu real(kind=wp), intent(in) :: abstol integer, intent(in) :: m real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: z (ldz,*) integer, intent(in) :: ldz integer, intent(in) :: isuppz (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info","tags":"","loc":"interface/cheevr.html"},{"title":"zheevr – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zheevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: range character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: vl real(kind=wp), intent(in) :: vu integer, intent(in) :: il integer, intent(in) :: iu real(kind=wp), intent(in) :: abstol integer, intent(in) :: m real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: z (ldz,*) integer, intent(in) :: ldz integer, intent(in) :: isuppz (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info","tags":"","loc":"interface/zheevr.html"},{"title":"f77_heevr – MFI - Modern Fortran Interfaces","text":"public interface f77_heevr Module Procedures public  interface cheevr () Arguments None public  interface zheevr () Arguments None","tags":"","loc":"interface/f77_heevr.html"},{"title":"sgesvd – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: s (*) real(kind=wp), intent(out) :: u (ldu,*) integer, intent(in) :: ldu real(kind=wp), intent(out) :: vt (ldvt,*) integer, intent(in) :: ldvt real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/sgesvd.html"},{"title":"dgesvd – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: s (*) real(kind=wp), intent(out) :: u (ldu,*) integer, intent(in) :: ldu real(kind=wp), intent(out) :: vt (ldvt,*) integer, intent(in) :: ldvt real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","loc":"interface/dgesvd.html"},{"title":"cgesvd – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: s (*) complex(kind=wp), intent(out) :: u (ldu,*) integer, intent(in) :: ldu complex(kind=wp), intent(out) :: vt (ldvt,*) integer, intent(in) :: ldvt complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(in) :: rwork (*) integer, intent(out) :: info","tags":"","loc":"interface/cgesvd.html"},{"title":"zgesvd – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: s (*) complex(kind=wp), intent(out) :: u (ldu,*) integer, intent(in) :: ldu complex(kind=wp), intent(out) :: vt (ldvt,*) integer, intent(in) :: ldvt complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(in) :: rwork (*) integer, intent(out) :: info","tags":"","loc":"interface/zgesvd.html"},{"title":"f77_gesvd – MFI - Modern Fortran Interfaces","text":"public interface f77_gesvd Module Procedures public  interface sgesvd () Arguments None public  interface dgesvd () Arguments None public  interface cgesvd () Arguments None public  interface zgesvd () Arguments None","tags":"","loc":"interface/f77_gesvd.html"},{"title":"spotrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine spotrf(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info","tags":"","loc":"interface/spotrf.html"},{"title":"dpotrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dpotrf(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info","tags":"","loc":"interface/dpotrf.html"},{"title":"cpotrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cpotrf(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info","tags":"","loc":"interface/cpotrf.html"},{"title":"zpotrf – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zpotrf(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info","tags":"","loc":"interface/zpotrf.html"},{"title":"f77_potrf – MFI - Modern Fortran Interfaces","text":"public interface f77_potrf Module Procedures public  interface spotrf () Arguments None public  interface dpotrf () Arguments None public  interface cpotrf () Arguments None public  interface zpotrf () Arguments None","tags":"","loc":"interface/f77_potrf.html"},{"title":"spotri – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine spotri(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info","tags":"","loc":"interface/spotri.html"},{"title":"dpotri – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dpotri(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info","tags":"","loc":"interface/dpotri.html"},{"title":"cpotri – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cpotri(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info","tags":"","loc":"interface/cpotri.html"},{"title":"zpotri – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zpotri(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info","tags":"","loc":"interface/zpotri.html"},{"title":"f77_potri – MFI - Modern Fortran Interfaces","text":"public interface f77_potri Module Procedures public  interface spotri () Arguments None public  interface dpotri () Arguments None public  interface cpotri () Arguments None public  interface zpotri () Arguments None","tags":"","loc":"interface/f77_potri.html"},{"title":"spotrs – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine spotrs(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: nrhs real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","loc":"interface/spotrs.html"},{"title":"dpotrs – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dpotrs(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: nrhs real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","loc":"interface/dpotrs.html"},{"title":"cpotrs – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cpotrs(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","loc":"interface/cpotrs.html"},{"title":"zpotrs – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zpotrs(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","loc":"interface/zpotrs.html"},{"title":"f77_potrs – MFI - Modern Fortran Interfaces","text":"public interface f77_potrs Module Procedures public  interface spotrs () Arguments None public  interface dpotrs () Arguments None public  interface cpotrs () Arguments None public  interface zpotrs () Arguments None","tags":"","loc":"interface/f77_potrs.html"},{"title":"spocon – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine spocon(uplo, n, a, lda, anorm, rcond, work, iwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond real(kind=wp), intent(inout) :: work (*) integer, intent(inout) :: iwork (*) integer, intent(out) :: info Description spocon estimates the reciprocal of the condition number (in the\n1-norm) of a real(REAL32) Hermitian positive definite matrix using the\nCholesky factorization A = U H U or A = L L H computed by sPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).","tags":"","loc":"interface/spocon.html"},{"title":"dpocon – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dpocon(uplo, n, a, lda, anorm, rcond, work, iwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond real(kind=wp), intent(inout) :: work (*) integer, intent(inout) :: iwork (*) integer, intent(out) :: info Description dpocon estimates the reciprocal of the condition number (in the\n1-norm) of a real(REAL64) Hermitian positive definite matrix using the\nCholesky factorization A = U H U or A = L L H computed by dPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).","tags":"","loc":"interface/dpocon.html"},{"title":"cpocon – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cpocon(uplo, n, a, lda, anorm, rcond, work, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond complex(kind=wp), intent(inout) :: work (*) real(kind=wp), intent(inout) :: rwork (*) integer, intent(out) :: info Description cpocon estimates the reciprocal of the condition number (in the\n1-norm) of a complex(REAL32) Hermitian positive definite matrix using the\nCholesky factorization A = U H U or A = L L H computed by cPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).","tags":"","loc":"interface/cpocon.html"},{"title":"zpocon – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zpocon(uplo, n, a, lda, anorm, rcond, work, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond complex(kind=wp), intent(inout) :: work (*) real(kind=wp), intent(inout) :: rwork (*) integer, intent(out) :: info Description zpocon estimates the reciprocal of the condition number (in the\n1-norm) of a complex(REAL64) Hermitian positive definite matrix using the\nCholesky factorization A = U H U or A = L L H computed by zPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).","tags":"","loc":"interface/zpocon.html"},{"title":"f77_pocon – MFI - Modern Fortran Interfaces","text":"public interface f77_pocon Module Procedures public  interface spocon () Arguments None public  interface dpocon () Arguments None public  interface cpocon () Arguments None public  interface zpocon () Arguments None","tags":"","loc":"interface/f77_pocon.html"},{"title":"slartg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine slartg(f, g, c, s, r) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: f real(kind=wp), intent(inout) :: g real(kind=wp), intent(inout) :: c real(kind=wp), intent(inout) :: s real(kind=wp), intent(inout) :: r","tags":"","loc":"interface/slartg.html"},{"title":"dlartg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dlartg(f, g, c, s, r) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: f real(kind=wp), intent(inout) :: g real(kind=wp), intent(inout) :: c real(kind=wp), intent(inout) :: s real(kind=wp), intent(inout) :: r","tags":"","loc":"interface/dlartg.html"},{"title":"clartg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine clartg(f, g, c, s, r) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: f complex(kind=wp), intent(inout) :: g real(kind=wp), intent(inout) :: c complex(kind=wp), intent(inout) :: s complex(kind=wp), intent(inout) :: r","tags":"","loc":"interface/clartg.html"},{"title":"zlartg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zlartg(f, g, c, s, r) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: f complex(kind=wp), intent(inout) :: g real(kind=wp), intent(inout) :: c complex(kind=wp), intent(inout) :: s complex(kind=wp), intent(inout) :: r","tags":"","loc":"interface/zlartg.html"},{"title":"f77_lartg – MFI - Modern Fortran Interfaces","text":"public interface f77_lartg Module Procedures public  interface slartg () Arguments None public  interface dlartg () Arguments None public  interface clartg () Arguments None public  interface zlartg () Arguments None","tags":"","loc":"interface/f77_lartg.html"},{"title":"f77_xerbla – MFI - Modern Fortran Interfaces","text":"public interface f77_xerbla Subroutines public pure subroutine xerbla(name, info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name integer, intent(in) :: info","tags":"","loc":"interface/f77_xerbla.html"},{"title":"isamax – MFI - Modern Fortran Interfaces","text":"public pure function isamax(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"proc/isamax.html"},{"title":"idamax – MFI - Modern Fortran Interfaces","text":"public pure function idamax(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"proc/idamax.html"},{"title":"icamax – MFI - Modern Fortran Interfaces","text":"public pure function icamax(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"proc/icamax.html"},{"title":"izamax – MFI - Modern Fortran Interfaces","text":"public pure function izamax(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"proc/izamax.html"},{"title":"isamin – MFI - Modern Fortran Interfaces","text":"public pure function isamin(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"proc/isamin.html"},{"title":"idamin – MFI - Modern Fortran Interfaces","text":"public pure function idamin(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"proc/idamin.html"},{"title":"icamin – MFI - Modern Fortran Interfaces","text":"public pure function icamin(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"proc/icamin.html"},{"title":"izamin – MFI - Modern Fortran Interfaces","text":"public pure function izamin(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"proc/izamin.html"},{"title":"saxpy – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine saxpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/saxpy.html"},{"title":"daxpy – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine daxpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/daxpy.html"},{"title":"caxpy – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine caxpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: a complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/caxpy.html"},{"title":"zaxpy – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zaxpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: a complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/zaxpy.html"},{"title":"f77_axpy – MFI - Modern Fortran Interfaces","text":"public interface f77_axpy Module Procedures public  interface saxpy () Arguments None public  interface daxpy () Arguments None public  interface caxpy () Arguments None public  interface zaxpy () Arguments None","tags":"","loc":"interface/f77_axpy.html"},{"title":"scopy – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine scopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/scopy.html"},{"title":"dcopy – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/dcopy.html"},{"title":"ccopy – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ccopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/ccopy.html"},{"title":"zcopy – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/zcopy.html"},{"title":"f77_copy – MFI - Modern Fortran Interfaces","text":"public interface f77_copy Module Procedures public  interface scopy () Arguments None public  interface dcopy () Arguments None public  interface ccopy () Arguments None public  interface zcopy () Arguments None","tags":"","loc":"interface/f77_copy.html"},{"title":"sdot – MFI - Modern Fortran Interfaces","text":"interface public pure function sdot(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value real(kind=wp)","tags":"","loc":"interface/sdot.html"},{"title":"ddot – MFI - Modern Fortran Interfaces","text":"interface public pure function ddot(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value real(kind=wp)","tags":"","loc":"interface/ddot.html"},{"title":"f77_dot – MFI - Modern Fortran Interfaces","text":"public interface f77_dot Module Procedures public  interface sdot () Arguments None public  interface ddot () Arguments None","tags":"","loc":"interface/f77_dot.html"},{"title":"cdotu – MFI - Modern Fortran Interfaces","text":"interface public pure function cdotu(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value complex(kind=wp)","tags":"","loc":"interface/cdotu.html"},{"title":"zdotu – MFI - Modern Fortran Interfaces","text":"interface public pure function zdotu(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value complex(kind=wp)","tags":"","loc":"interface/zdotu.html"},{"title":"f77_dotu – MFI - Modern Fortran Interfaces","text":"public interface f77_dotu Module Procedures public  interface cdotu () Arguments None public  interface zdotu () Arguments None","tags":"","loc":"interface/f77_dotu.html"},{"title":"cdotc – MFI - Modern Fortran Interfaces","text":"interface public pure function cdotc(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value complex(kind=wp)","tags":"","loc":"interface/cdotc.html"},{"title":"zdotc – MFI - Modern Fortran Interfaces","text":"interface public pure function zdotc(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value complex(kind=wp)","tags":"","loc":"interface/zdotc.html"},{"title":"f77_dotc – MFI - Modern Fortran Interfaces","text":"public interface f77_dotc Module Procedures public  interface cdotc () Arguments None public  interface zdotc () Arguments None","tags":"","loc":"interface/f77_dotc.html"},{"title":"srotg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine srotg(a, b, c, s) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s Description srotg generates a Givens rotation with real cosine and complex sine: [ c s ] [ a ] = [ r ] [ - s c ] [ b ] [ 0 ] satisfying c**2 + s**2 = 1 .","tags":"","loc":"interface/srotg.html"},{"title":"drotg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine drotg(a, b, c, s) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s Description drotg generates a Givens rotation with real cosine and complex sine: [ c s ] [ a ] = [ r ] [ - s c ] [ b ] [ 0 ] satisfying c**2 + s**2 = 1 .","tags":"","loc":"interface/drotg.html"},{"title":"crotg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine crotg(a, b, c, s) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a complex(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c complex(kind=wp), intent(out) :: s Description crotg generates a Givens rotation with real cosine and complex sine: [ c s ] [ a ] = [ r ] [ - conjg ( s ) c ] [ b ] [ 0 ] where c is real, s is complex, and c**2 + conjg(s)*s = 1 .","tags":"","loc":"interface/crotg.html"},{"title":"zrotg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zrotg(a, b, c, s) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a complex(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c complex(kind=wp), intent(out) :: s Description zrotg generates a Givens rotation with real cosine and complex sine: [ c s ] [ a ] = [ r ] [ - conjg ( s ) c ] [ b ] [ 0 ] where c is real, s is complex, and c**2 + conjg(s)*s = 1 .","tags":"","loc":"interface/zrotg.html"},{"title":"f77_rotg – MFI - Modern Fortran Interfaces","text":"public interface f77_rotg Module Procedures public  interface srotg () Arguments None public  interface drotg () Arguments None public  interface crotg () Arguments None public  interface zrotg () Arguments None","tags":"","loc":"interface/f77_rotg.html"},{"title":"srotm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine srotm(n, x, incx, y, incy, param) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: param (5)","tags":"","loc":"interface/srotm.html"},{"title":"drotm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine drotm(n, x, incx, y, incy, param) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: param (5)","tags":"","loc":"interface/drotm.html"},{"title":"f77_rotm – MFI - Modern Fortran Interfaces","text":"public interface f77_rotm Module Procedures public  interface srotm () Arguments None public  interface drotm () Arguments None","tags":"","loc":"interface/f77_rotm.html"},{"title":"srotmg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine srotmg(d1, d2, x1, y1, param) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: d1 real(kind=wp), intent(inout) :: d2 real(kind=wp), intent(inout) :: x1 real(kind=wp), intent(in) :: y1 real(kind=wp), intent(out) :: param (5)","tags":"","loc":"interface/srotmg.html"},{"title":"drotmg – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine drotmg(d1, d2, x1, y1, param) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: d1 real(kind=wp), intent(inout) :: d2 real(kind=wp), intent(inout) :: x1 real(kind=wp), intent(in) :: y1 real(kind=wp), intent(out) :: param (5)","tags":"","loc":"interface/drotmg.html"},{"title":"f77_rotmg – MFI - Modern Fortran Interfaces","text":"public interface f77_rotmg Module Procedures public  interface srotmg () Arguments None public  interface drotmg () Arguments None","tags":"","loc":"interface/f77_rotmg.html"},{"title":"sswap – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sswap(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/sswap.html"},{"title":"dswap – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dswap(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/dswap.html"},{"title":"cswap – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cswap(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/cswap.html"},{"title":"zswap – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zswap(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/zswap.html"},{"title":"f77_swap – MFI - Modern Fortran Interfaces","text":"public interface f77_swap Module Procedures public  interface sswap () Arguments None public  interface dswap () Arguments None public  interface cswap () Arguments None public  interface zswap () Arguments None","tags":"","loc":"interface/f77_swap.html"},{"title":"sasum – MFI - Modern Fortran Interfaces","text":"interface public pure function sasum(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp)","tags":"","loc":"interface/sasum.html"},{"title":"dasum – MFI - Modern Fortran Interfaces","text":"interface public pure function dasum(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp)","tags":"","loc":"interface/dasum.html"},{"title":"scasum – MFI - Modern Fortran Interfaces","text":"interface public pure function scasum(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp)","tags":"","loc":"interface/scasum.html"},{"title":"dzasum – MFI - Modern Fortran Interfaces","text":"interface public pure function dzasum(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp)","tags":"","loc":"interface/dzasum.html"},{"title":"f77_asum – MFI - Modern Fortran Interfaces","text":"public interface f77_asum Module Procedures public  interface sasum () Arguments None public  interface dasum () Arguments None public  interface scasum () Arguments None public  interface dzasum () Arguments None","tags":"","loc":"interface/f77_asum.html"},{"title":"snrm2 – MFI - Modern Fortran Interfaces","text":"interface public pure function snrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp)","tags":"","loc":"interface/snrm2.html"},{"title":"dnrm2 – MFI - Modern Fortran Interfaces","text":"interface public pure function dnrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp)","tags":"","loc":"interface/dnrm2.html"},{"title":"scnrm2 – MFI - Modern Fortran Interfaces","text":"interface public pure function scnrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp)","tags":"","loc":"interface/scnrm2.html"},{"title":"dznrm2 – MFI - Modern Fortran Interfaces","text":"interface public pure function dznrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp)","tags":"","loc":"interface/dznrm2.html"},{"title":"f77_nrm2 – MFI - Modern Fortran Interfaces","text":"public interface f77_nrm2 Module Procedures public  interface snrm2 () Arguments None public  interface dnrm2 () Arguments None public  interface scnrm2 () Arguments None public  interface dznrm2 () Arguments None","tags":"","loc":"interface/f77_nrm2.html"},{"title":"sscal – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sscal(n, a, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx Description SSCAL scales a vector by a constant.","tags":"","loc":"interface/sscal.html"},{"title":"dscal – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dscal(n, a, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx Description DSCAL scales a vector by a constant.","tags":"","loc":"interface/dscal.html"},{"title":"cscal – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cscal(n, a, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: a complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx Description CSCAL scales a vector by a constant.","tags":"","loc":"interface/cscal.html"},{"title":"zscal – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zscal(n, a, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: a complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx Description ZSCAL scales a vector by a constant.","tags":"","loc":"interface/zscal.html"},{"title":"csscal – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine csscal(n, a, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx Description CSSCAL scales a vector by a constant.","tags":"","loc":"interface/csscal.html"},{"title":"zdscal – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zdscal(n, a, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx Description ZDSCAL scales a vector by a constant.","tags":"","loc":"interface/zdscal.html"},{"title":"f77_scal – MFI - Modern Fortran Interfaces","text":"public interface f77_scal Module Procedures public  interface sscal () Arguments None public  interface dscal () Arguments None public  interface cscal () Arguments None public  interface zscal () Arguments None public  interface csscal () Arguments None public  interface zdscal () Arguments None","tags":"","loc":"interface/f77_scal.html"},{"title":"srot – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine srot(n, x, incx, y, incy, c, s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s Description SROT applies a plane rotation.","tags":"","loc":"interface/srot.html"},{"title":"drot – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine drot(n, x, incx, y, incy, c, s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s Description DROT applies a plane rotation.","tags":"","loc":"interface/drot.html"},{"title":"crot – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine crot(n, x, incx, y, incy, c, s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s Description CROT applies a plane rotation.","tags":"","loc":"interface/crot.html"},{"title":"zrot – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zrot(n, x, incx, y, incy, c, s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s Description ZROT applies a plane rotation.","tags":"","loc":"interface/zrot.html"},{"title":"csrot – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine csrot(n, x, incx, y, incy, c, s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s Description CSROT applies a plane rotation,\nwhere the cos and sin (c and s) are real\nand the vectors x and y are complex.","tags":"","loc":"interface/csrot.html"},{"title":"zdrot – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zdrot(n, x, incx, y, incy, c, s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s Description ZDROT applies a plane rotation,\nwhere the cos and sin (c and s) are real\nand the vectors x and y are complex.","tags":"","loc":"interface/zdrot.html"},{"title":"f77_rot – MFI - Modern Fortran Interfaces","text":"public interface f77_rot Module Procedures public  interface srot () Arguments None public  interface drot () Arguments None public  interface crot () Arguments None public  interface zrot () Arguments None public  interface csrot () Arguments None public  interface zdrot () Arguments None","tags":"","loc":"interface/f77_rot.html"},{"title":"sgbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/sgbmv.html"},{"title":"dgbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/dgbmv.html"},{"title":"cgbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/cgbmv.html"},{"title":"zgbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/zgbmv.html"},{"title":"f77_gbmv – MFI - Modern Fortran Interfaces","text":"public interface f77_gbmv Module Procedures public  interface sgbmv () Arguments None public  interface dgbmv () Arguments None public  interface cgbmv () Arguments None public  interface zgbmv () Arguments None","tags":"","loc":"interface/f77_gbmv.html"},{"title":"sgemv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/sgemv.html"},{"title":"dgemv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/dgemv.html"},{"title":"cgemv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/cgemv.html"},{"title":"zgemv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/zgemv.html"},{"title":"f77_gemv – MFI - Modern Fortran Interfaces","text":"public interface f77_gemv Module Procedures public  interface sgemv () Arguments None public  interface dgemv () Arguments None public  interface cgemv () Arguments None public  interface zgemv () Arguments None","tags":"","loc":"interface/f77_gemv.html"},{"title":"sger – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sger(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/sger.html"},{"title":"dger – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dger(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/dger.html"},{"title":"f77_ger – MFI - Modern Fortran Interfaces","text":"public interface f77_ger Module Procedures public  interface sger () Arguments None public  interface dger () Arguments None","tags":"","loc":"interface/f77_ger.html"},{"title":"cgerc – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgerc(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/cgerc.html"},{"title":"zgerc – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgerc(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/zgerc.html"},{"title":"f77_gerc – MFI - Modern Fortran Interfaces","text":"public interface f77_gerc Module Procedures public  interface cgerc () Arguments None public  interface zgerc () Arguments None","tags":"","loc":"interface/f77_gerc.html"},{"title":"cgeru – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgeru(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/cgeru.html"},{"title":"zgeru – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgeru(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/zgeru.html"},{"title":"f77_geru – MFI - Modern Fortran Interfaces","text":"public interface f77_geru Module Procedures public  interface cgeru () Arguments None public  interface zgeru () Arguments None","tags":"","loc":"interface/f77_geru.html"},{"title":"chbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine chbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/chbmv.html"},{"title":"zhbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zhbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/zhbmv.html"},{"title":"f77_hbmv – MFI - Modern Fortran Interfaces","text":"public interface f77_hbmv Module Procedures public  interface chbmv () Arguments None public  interface zhbmv () Arguments None","tags":"","loc":"interface/f77_hbmv.html"},{"title":"chemv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine chemv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/chemv.html"},{"title":"zhemv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zhemv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/zhemv.html"},{"title":"f77_hemv – MFI - Modern Fortran Interfaces","text":"public interface f77_hemv Module Procedures public  interface chemv () Arguments None public  interface zhemv () Arguments None","tags":"","loc":"interface/f77_hemv.html"},{"title":"cher – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cher(uplo, n, alpha, x, incx, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/cher.html"},{"title":"zher – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zher(uplo, n, alpha, x, incx, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/zher.html"},{"title":"f77_her – MFI - Modern Fortran Interfaces","text":"public interface f77_her Module Procedures public  interface cher () Arguments None public  interface zher () Arguments None","tags":"","loc":"interface/f77_her.html"},{"title":"cher2 – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cher2(uplo, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/cher2.html"},{"title":"zher2 – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zher2(uplo, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/zher2.html"},{"title":"f77_her2 – MFI - Modern Fortran Interfaces","text":"public interface f77_her2 Module Procedures public  interface cher2 () Arguments None public  interface zher2 () Arguments None","tags":"","loc":"interface/f77_her2.html"},{"title":"chpmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine chpmv(uplo, n, alpha, ap, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/chpmv.html"},{"title":"zhpmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zhpmv(uplo, n, alpha, ap, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/zhpmv.html"},{"title":"f77_hpmv – MFI - Modern Fortran Interfaces","text":"public interface f77_hpmv Module Procedures public  interface chpmv () Arguments None public  interface zhpmv () Arguments None","tags":"","loc":"interface/f77_hpmv.html"},{"title":"chpr – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine chpr(uplo, n, alpha, x, incx, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: ap (*)","tags":"","loc":"interface/chpr.html"},{"title":"zhpr – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zhpr(uplo, n, alpha, x, incx, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: ap (*)","tags":"","loc":"interface/zhpr.html"},{"title":"f77_hpr – MFI - Modern Fortran Interfaces","text":"public interface f77_hpr Module Procedures public  interface chpr () Arguments None public  interface zhpr () Arguments None","tags":"","loc":"interface/f77_hpr.html"},{"title":"chpr2 – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine chpr2(uplo, n, alpha, x, incx, y, incy, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: ap (*)","tags":"","loc":"interface/chpr2.html"},{"title":"zhpr2 – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zhpr2(uplo, n, alpha, x, incx, y, incy, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: ap (*)","tags":"","loc":"interface/zhpr2.html"},{"title":"f77_hpr2 – MFI - Modern Fortran Interfaces","text":"public interface f77_hpr2 Module Procedures public  interface chpr2 () Arguments None public  interface zhpr2 () Arguments None","tags":"","loc":"interface/f77_hpr2.html"},{"title":"ssbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ssbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/ssbmv.html"},{"title":"dsbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dsbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/dsbmv.html"},{"title":"f77_sbmv – MFI - Modern Fortran Interfaces","text":"public interface f77_sbmv Module Procedures public  interface ssbmv () Arguments None public  interface dsbmv () Arguments None","tags":"","loc":"interface/f77_sbmv.html"},{"title":"sspmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sspmv(uplo, n, alpha, ap, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/sspmv.html"},{"title":"dspmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dspmv(uplo, n, alpha, ap, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/dspmv.html"},{"title":"f77_spmv – MFI - Modern Fortran Interfaces","text":"public interface f77_spmv Module Procedures public  interface sspmv () Arguments None public  interface dspmv () Arguments None","tags":"","loc":"interface/f77_spmv.html"},{"title":"sspr – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sspr(uplo, n, alpha, x, incx, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: ap (*)","tags":"","loc":"interface/sspr.html"},{"title":"dspr – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dspr(uplo, n, alpha, x, incx, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: ap (*)","tags":"","loc":"interface/dspr.html"},{"title":"f77_spr – MFI - Modern Fortran Interfaces","text":"public interface f77_spr Module Procedures public  interface sspr () Arguments None public  interface dspr () Arguments None","tags":"","loc":"interface/f77_spr.html"},{"title":"sspr2 – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sspr2(uplo, n, alpha, x, incx, y, incy, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: ap (*)","tags":"","loc":"interface/sspr2.html"},{"title":"dspr2 – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dspr2(uplo, n, alpha, x, incx, y, incy, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: ap (*)","tags":"","loc":"interface/dspr2.html"},{"title":"f77_spr2 – MFI - Modern Fortran Interfaces","text":"public interface f77_spr2 Module Procedures public  interface sspr2 () Arguments None public  interface dspr2 () Arguments None","tags":"","loc":"interface/f77_spr2.html"},{"title":"ssymv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ssymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/ssymv.html"},{"title":"dsymv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dsymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy","tags":"","loc":"interface/dsymv.html"},{"title":"f77_symv – MFI - Modern Fortran Interfaces","text":"public interface f77_symv Module Procedures public  interface ssymv () Arguments None public  interface dsymv () Arguments None","tags":"","loc":"interface/f77_symv.html"},{"title":"ssyr – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ssyr(uplo, n, alpha, x, incx, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/ssyr.html"},{"title":"dsyr – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dsyr(uplo, n, alpha, x, incx, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/dsyr.html"},{"title":"f77_syr – MFI - Modern Fortran Interfaces","text":"public interface f77_syr Module Procedures public  interface ssyr () Arguments None public  interface dsyr () Arguments None","tags":"","loc":"interface/f77_syr.html"},{"title":"ssyr2 – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ssyr2(uplo, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/ssyr2.html"},{"title":"dsyr2 – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dsyr2(uplo, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda","tags":"","loc":"interface/dsyr2.html"},{"title":"f77_syr2 – MFI - Modern Fortran Interfaces","text":"public interface f77_syr2 Module Procedures public  interface ssyr2 () Arguments None public  interface dsyr2 () Arguments None","tags":"","loc":"interface/f77_syr2.html"},{"title":"stbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine stbmv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/stbmv.html"},{"title":"dtbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dtbmv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/dtbmv.html"},{"title":"ctbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ctbmv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ctbmv.html"},{"title":"ztbmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ztbmv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ztbmv.html"},{"title":"f77_tbmv – MFI - Modern Fortran Interfaces","text":"public interface f77_tbmv Module Procedures public  interface stbmv () Arguments None public  interface dtbmv () Arguments None public  interface ctbmv () Arguments None public  interface ztbmv () Arguments None","tags":"","loc":"interface/f77_tbmv.html"},{"title":"stbsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine stbsv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/stbsv.html"},{"title":"dtbsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dtbsv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/dtbsv.html"},{"title":"ctbsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ctbsv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ctbsv.html"},{"title":"ztbsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ztbsv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ztbsv.html"},{"title":"f77_tbsv – MFI - Modern Fortran Interfaces","text":"public interface f77_tbsv Module Procedures public  interface stbsv () Arguments None public  interface dtbsv () Arguments None public  interface ctbsv () Arguments None public  interface ztbsv () Arguments None","tags":"","loc":"interface/f77_tbsv.html"},{"title":"stpmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine stpmv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/stpmv.html"},{"title":"dtpmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dtpmv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/dtpmv.html"},{"title":"ctpmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ctpmv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ctpmv.html"},{"title":"ztpmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ztpmv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ztpmv.html"},{"title":"f77_tpmv – MFI - Modern Fortran Interfaces","text":"public interface f77_tpmv Module Procedures public  interface stpmv () Arguments None public  interface dtpmv () Arguments None public  interface ctpmv () Arguments None public  interface ztpmv () Arguments None","tags":"","loc":"interface/f77_tpmv.html"},{"title":"stpsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine stpsv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/stpsv.html"},{"title":"dtpsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dtpsv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/dtpsv.html"},{"title":"ctpsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ctpsv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ctpsv.html"},{"title":"ztpsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ztpsv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ztpsv.html"},{"title":"f77_tpsv – MFI - Modern Fortran Interfaces","text":"public interface f77_tpsv Module Procedures public  interface stpsv () Arguments None public  interface dtpsv () Arguments None public  interface ctpsv () Arguments None public  interface ztpsv () Arguments None","tags":"","loc":"interface/f77_tpsv.html"},{"title":"strmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine strmv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/strmv.html"},{"title":"dtrmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dtrmv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/dtrmv.html"},{"title":"ctrmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ctrmv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ctrmv.html"},{"title":"ztrmv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ztrmv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ztrmv.html"},{"title":"f77_trmv – MFI - Modern Fortran Interfaces","text":"public interface f77_trmv Module Procedures public  interface strmv () Arguments None public  interface dtrmv () Arguments None public  interface ctrmv () Arguments None public  interface ztrmv () Arguments None","tags":"","loc":"interface/f77_trmv.html"},{"title":"strsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine strsv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/strsv.html"},{"title":"dtrsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dtrsv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/dtrsv.html"},{"title":"ctrsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ctrsv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ctrsv.html"},{"title":"ztrsv – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ztrsv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"interface/ztrsv.html"},{"title":"f77_trsv – MFI - Modern Fortran Interfaces","text":"public interface f77_trsv Module Procedures public  interface strsv () Arguments None public  interface dtrsv () Arguments None public  interface ctrsv () Arguments None public  interface ztrsv () Arguments None","tags":"","loc":"interface/f77_trsv.html"},{"title":"sgemm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine sgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/sgemm.html"},{"title":"dgemm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/dgemm.html"},{"title":"cgemm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/cgemm.html"},{"title":"zgemm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/zgemm.html"},{"title":"f77_gemm – MFI - Modern Fortran Interfaces","text":"public interface f77_gemm Module Procedures public  interface sgemm () Arguments None public  interface dgemm () Arguments None public  interface cgemm () Arguments None public  interface zgemm () Arguments None","tags":"","loc":"interface/f77_gemm.html"},{"title":"chemm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine chemm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/chemm.html"},{"title":"zhemm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zhemm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/zhemm.html"},{"title":"f77_hemm – MFI - Modern Fortran Interfaces","text":"public interface f77_hemm Module Procedures public  interface chemm () Arguments None public  interface zhemm () Arguments None","tags":"","loc":"interface/f77_hemm.html"},{"title":"cherk – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cherk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/cherk.html"},{"title":"zherk – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zherk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/zherk.html"},{"title":"f77_herk – MFI - Modern Fortran Interfaces","text":"public interface f77_herk Module Procedures public  interface cherk () Arguments None public  interface zherk () Arguments None","tags":"","loc":"interface/f77_herk.html"},{"title":"cher2k – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine cher2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/cher2k.html"},{"title":"zher2k – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine zher2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/zher2k.html"},{"title":"f77_her2k – MFI - Modern Fortran Interfaces","text":"public interface f77_her2k Module Procedures public  interface cher2k () Arguments None public  interface zher2k () Arguments None","tags":"","loc":"interface/f77_her2k.html"},{"title":"ssymm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ssymm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/ssymm.html"},{"title":"dsymm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dsymm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/dsymm.html"},{"title":"f77_symm – MFI - Modern Fortran Interfaces","text":"public interface f77_symm Module Procedures public  interface ssymm () Arguments None public  interface dsymm () Arguments None","tags":"","loc":"interface/f77_symm.html"},{"title":"ssyrk – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ssyrk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/ssyrk.html"},{"title":"dsyrk – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dsyrk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/dsyrk.html"},{"title":"f77_syrk – MFI - Modern Fortran Interfaces","text":"public interface f77_syrk Module Procedures public  interface ssyrk () Arguments None public  interface dsyrk () Arguments None","tags":"","loc":"interface/f77_syrk.html"},{"title":"ssyr2k – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ssyr2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/ssyr2k.html"},{"title":"dsyr2k – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dsyr2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc","tags":"","loc":"interface/dsyr2k.html"},{"title":"f77_syr2k – MFI - Modern Fortran Interfaces","text":"public interface f77_syr2k Module Procedures public  interface ssyr2k () Arguments None public  interface dsyr2k () Arguments None","tags":"","loc":"interface/f77_syr2k.html"},{"title":"strmm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine strmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb","tags":"","loc":"interface/strmm.html"},{"title":"dtrmm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dtrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb","tags":"","loc":"interface/dtrmm.html"},{"title":"ctrmm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ctrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb","tags":"","loc":"interface/ctrmm.html"},{"title":"ztrmm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ztrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb","tags":"","loc":"interface/ztrmm.html"},{"title":"f77_trmm – MFI - Modern Fortran Interfaces","text":"public interface f77_trmm Module Procedures public  interface strmm () Arguments None public  interface dtrmm () Arguments None public  interface ctrmm () Arguments None public  interface ztrmm () Arguments None","tags":"","loc":"interface/f77_trmm.html"},{"title":"strsm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine strsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb","tags":"","loc":"interface/strsm.html"},{"title":"dtrsm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine dtrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb","tags":"","loc":"interface/dtrsm.html"},{"title":"ctrsm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ctrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb","tags":"","loc":"interface/ctrsm.html"},{"title":"ztrsm – MFI - Modern Fortran Interfaces","text":"interface public pure subroutine ztrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb","tags":"","loc":"interface/ztrsm.html"},{"title":"f77_trsm – MFI - Modern Fortran Interfaces","text":"public interface f77_trsm Module Procedures public  interface strsm () Arguments None public  interface dtrsm () Arguments None public  interface ctrsm () Arguments None public  interface ztrsm () Arguments None","tags":"","loc":"interface/f77_trsm.html"},{"title":"slamch – MFI - Modern Fortran Interfaces","text":"interface public pure function slamch(cmach) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach Return Value real(kind=real32) Description SLAMCH determines single precision machine parameters.","tags":"","loc":"interface/slamch.html"},{"title":"dlamch – MFI - Modern Fortran Interfaces","text":"interface public pure function dlamch(cmach) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach Return Value real(kind=real64) Description DLAMCH determines double precision machine parameters.","tags":"","loc":"interface/dlamch.html"},{"title":"sdsdot – MFI - Modern Fortran Interfaces","text":"interface public pure function sdsdot(n, sb, sx, incx, sy, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: sb real(kind=wp), intent(in) :: sx (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: sy (*) integer, intent(in) :: incy Return Value real(kind=wp) Description Compute the inner product of two vectors with extended\nprecision accumulation. Returns S.P. result with dot product accumulated in D.P.\nSDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I INCX) SY(LY+I INCY),\nwhere LX = 1 if INCX .GE. 0, else LX = 1+(1-N) INCX, and LY is\ndefined in a similar way using INCY.","tags":"","loc":"interface/sdsdot.html"},{"title":"dsdot – MFI - Modern Fortran Interfaces","text":"interface public pure function dsdot(n, sx, incx, sy, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=sp), intent(in) :: sx (*) integer, intent(in) :: incx real(kind=sp), intent(in) :: sy (*) integer, intent(in) :: incy Return Value real(kind=dp) Description Compute the inner product of two vectors with extended\nprecision accumulation and result. Returns D.P. dot product accumulated in D.P., for S.P. SX and SY\nDSDOT = sum for I = 0 to N-1 of  SX(LX+I INCX) * SY(LY+I INCY),\nwhere LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is\ndefined in a similar way using INCY.","tags":"","loc":"interface/dsdot.html"},{"title":"f77_iamax – MFI - Modern Fortran Interfaces","text":"public interface f77_iamax Module Procedures public pure function isamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function idamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function icamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function izamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"interface/f77_iamax.html"},{"title":"f77_iamin – MFI - Modern Fortran Interfaces","text":"public interface f77_iamin Module Procedures public pure function isamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function idamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function icamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function izamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"interface/f77_iamin.html"},{"title":"mfi_snrm2 – MFI - Modern Fortran Interfaces","text":"public pure function mfi_snrm2(x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"proc/mfi_snrm2.html"},{"title":"mfi_dnrm2 – MFI - Modern Fortran Interfaces","text":"public pure function mfi_dnrm2(x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"proc/mfi_dnrm2.html"},{"title":"mfi_scnrm2 – MFI - Modern Fortran Interfaces","text":"public pure function mfi_scnrm2(x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"proc/mfi_scnrm2.html"},{"title":"mfi_dznrm2 – MFI - Modern Fortran Interfaces","text":"public pure function mfi_dznrm2(x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"proc/mfi_dznrm2.html"},{"title":"mfi_sasum – MFI - Modern Fortran Interfaces","text":"public pure function mfi_sasum(x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"proc/mfi_sasum.html"},{"title":"mfi_dasum – MFI - Modern Fortran Interfaces","text":"public pure function mfi_dasum(x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"proc/mfi_dasum.html"},{"title":"mfi_scasum – MFI - Modern Fortran Interfaces","text":"public pure function mfi_scasum(x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"proc/mfi_scasum.html"},{"title":"mfi_dzasum – MFI - Modern Fortran Interfaces","text":"public pure function mfi_dzasum(x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"proc/mfi_dzasum.html"},{"title":"mfi_sdot – MFI - Modern Fortran Interfaces","text":"public pure function mfi_sdot(x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value real(kind=wp)","tags":"","loc":"proc/mfi_sdot.html"},{"title":"mfi_ddot – MFI - Modern Fortran Interfaces","text":"public pure function mfi_ddot(x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value real(kind=wp)","tags":"","loc":"proc/mfi_ddot.html"},{"title":"mfi_cdotu – MFI - Modern Fortran Interfaces","text":"public pure function mfi_cdotu(x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp)","tags":"","loc":"proc/mfi_cdotu.html"},{"title":"mfi_zdotu – MFI - Modern Fortran Interfaces","text":"public pure function mfi_zdotu(x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp)","tags":"","loc":"proc/mfi_zdotu.html"},{"title":"mfi_cdotc – MFI - Modern Fortran Interfaces","text":"public pure function mfi_cdotc(x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp)","tags":"","loc":"proc/mfi_cdotc.html"},{"title":"mfi_zdotc – MFI - Modern Fortran Interfaces","text":"public pure function mfi_zdotc(x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp)","tags":"","loc":"proc/mfi_zdotc.html"},{"title":"mfi_isamax – MFI - Modern Fortran Interfaces","text":"public pure function mfi_isamax(x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"proc/mfi_isamax.html"},{"title":"mfi_idamax – MFI - Modern Fortran Interfaces","text":"public pure function mfi_idamax(x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"proc/mfi_idamax.html"},{"title":"mfi_icamax – MFI - Modern Fortran Interfaces","text":"public pure function mfi_icamax(x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"proc/mfi_icamax.html"},{"title":"mfi_izamax – MFI - Modern Fortran Interfaces","text":"public pure function mfi_izamax(x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"proc/mfi_izamax.html"},{"title":"mfi_isamin – MFI - Modern Fortran Interfaces","text":"public pure function mfi_isamin(x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"proc/mfi_isamin.html"},{"title":"mfi_idamin – MFI - Modern Fortran Interfaces","text":"public pure function mfi_idamin(x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"proc/mfi_idamin.html"},{"title":"mfi_icamin – MFI - Modern Fortran Interfaces","text":"public pure function mfi_icamin(x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"proc/mfi_icamin.html"},{"title":"mfi_izamin – MFI - Modern Fortran Interfaces","text":"public pure function mfi_izamin(x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"proc/mfi_izamin.html"},{"title":"mfi_slamch – MFI - Modern Fortran Interfaces","text":"public pure function mfi_slamch(cmach, kind) result(res) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach real(kind=wp), intent(in) :: kind Just a kind placeholder Return Value real(kind=wp)","tags":"","loc":"proc/mfi_slamch.html"},{"title":"mfi_dlamch – MFI - Modern Fortran Interfaces","text":"public pure function mfi_dlamch(cmach, kind) result(res) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach real(kind=wp), intent(in) :: kind Just a kind placeholder Return Value real(kind=wp)","tags":"","loc":"proc/mfi_dlamch.html"},{"title":"mfi_saxpy – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_saxpy(x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_saxpy.html"},{"title":"mfi_daxpy – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_daxpy(x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_daxpy.html"},{"title":"mfi_caxpy – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_caxpy(x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_caxpy.html"},{"title":"mfi_zaxpy – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zaxpy(x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zaxpy.html"},{"title":"mfi_scopy – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_scopy(x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_scopy.html"},{"title":"mfi_dcopy – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dcopy(x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dcopy.html"},{"title":"mfi_ccopy – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ccopy(x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_ccopy.html"},{"title":"mfi_zcopy – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zcopy(x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zcopy.html"},{"title":"mfi_srot – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_srot(x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - s * xi Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_srot.html"},{"title":"mfi_drot – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_drot(x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - s * xi Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_drot.html"},{"title":"mfi_crot – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_crot(x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - conj ( s ) * xi Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_crot.html"},{"title":"mfi_zrot – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zrot(x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - conj ( s ) * xi Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zrot.html"},{"title":"mfi_csrot – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_csrot(x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - conj ( s ) * xi Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_csrot.html"},{"title":"mfi_zdrot – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zdrot(x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - conj ( s ) * xi Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zdrot.html"},{"title":"mfi_srotm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_srotm(x, y, param, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: param (5) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_srotm.html"},{"title":"mfi_drotm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_drotm(x, y, param, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: param (5) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_drotm.html"},{"title":"mfi_sscal – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sscal(x, a, incx) MFI_SSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_sscal.html"},{"title":"mfi_dscal – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dscal(x, a, incx) MFI_DSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dscal.html"},{"title":"mfi_cscal – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cscal(x, a, incx) MFI_CSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(in) :: a integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_cscal.html"},{"title":"mfi_zscal – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zscal(x, a, incx) MFI_ZSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(in) :: a integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_zscal.html"},{"title":"mfi_csscal – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_csscal(x, a, incx) MFI_CSSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_csscal.html"},{"title":"mfi_zdscal – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zdscal(x, a, incx) MFI_ZDSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_zdscal.html"},{"title":"mfi_sswap – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sswap(x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_sswap.html"},{"title":"mfi_dswap – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dswap(x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dswap.html"},{"title":"mfi_cswap – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cswap(x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_cswap.html"},{"title":"mfi_zswap – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zswap(x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zswap.html"},{"title":"mfi_sgbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgbmv(a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_sgbmv.html"},{"title":"mfi_dgbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgbmv(a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dgbmv.html"},{"title":"mfi_cgbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgbmv(a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_cgbmv.html"},{"title":"mfi_zgbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgbmv(a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zgbmv.html"},{"title":"mfi_sgemv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgemv(a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_sgemv.html"},{"title":"mfi_dgemv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgemv(a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dgemv.html"},{"title":"mfi_cgemv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgemv(a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_cgemv.html"},{"title":"mfi_zgemv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgemv(a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zgemv.html"},{"title":"mfi_sger – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sger(a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_sger.html"},{"title":"mfi_dger – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dger(a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dger.html"},{"title":"mfi_cgerc – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgerc(a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_cgerc.html"},{"title":"mfi_zgerc – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgerc(a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zgerc.html"},{"title":"mfi_cgeru – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgeru(a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_cgeru.html"},{"title":"mfi_zgeru – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgeru(a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zgeru.html"},{"title":"mfi_chbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_chbmv(a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_chbmv.html"},{"title":"mfi_zhbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zhbmv(a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zhbmv.html"},{"title":"mfi_chemv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_chemv(a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_chemv.html"},{"title":"mfi_zhemv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zhemv(a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zhemv.html"},{"title":"mfi_cher – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cher(a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_cher.html"},{"title":"mfi_zher – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zher(a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_zher.html"},{"title":"mfi_cher2 – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cher2(a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_cher2.html"},{"title":"mfi_zher2 – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zher2(a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zher2.html"},{"title":"mfi_chpmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_chpmv(ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_chpmv.html"},{"title":"mfi_zhpmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zhpmv(ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zhpmv.html"},{"title":"mfi_chpr – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_chpr(ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_chpr.html"},{"title":"mfi_zhpr – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zhpr(ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_zhpr.html"},{"title":"mfi_chpr2 – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_chpr2(ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_chpr2.html"},{"title":"mfi_zhpr2 – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zhpr2(ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_zhpr2.html"},{"title":"mfi_ssbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ssbmv(a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_ssbmv.html"},{"title":"mfi_dsbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dsbmv(a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dsbmv.html"},{"title":"mfi_sspmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sspmv(ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_sspmv.html"},{"title":"mfi_dspmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dspmv(ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dspmv.html"},{"title":"mfi_sspr – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sspr(ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_sspr.html"},{"title":"mfi_dspr – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dspr(ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dspr.html"},{"title":"mfi_sspr2 – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sspr2(ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_sspr2.html"},{"title":"mfi_dspr2 – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dspr2(ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dspr2.html"},{"title":"mfi_ssymv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ssymv(a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_ssymv.html"},{"title":"mfi_dsymv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dsymv(a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dsymv.html"},{"title":"mfi_ssyr – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ssyr(a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ssyr.html"},{"title":"mfi_dsyr – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dsyr(a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dsyr.html"},{"title":"mfi_ssyr2 – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ssyr2(a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_ssyr2.html"},{"title":"mfi_dsyr2 – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dsyr2(a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"proc/mfi_dsyr2.html"},{"title":"mfi_stbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_stbmv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_stbmv.html"},{"title":"mfi_dtbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dtbmv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dtbmv.html"},{"title":"mfi_ctbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ctbmv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ctbmv.html"},{"title":"mfi_ztbmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ztbmv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ztbmv.html"},{"title":"mfi_stbsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_stbsv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_stbsv.html"},{"title":"mfi_dtbsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dtbsv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dtbsv.html"},{"title":"mfi_ctbsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ctbsv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ctbsv.html"},{"title":"mfi_ztbsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ztbsv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ztbsv.html"},{"title":"mfi_stpmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_stpmv(ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_stpmv.html"},{"title":"mfi_dtpmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dtpmv(ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dtpmv.html"},{"title":"mfi_ctpmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ctpmv(ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ctpmv.html"},{"title":"mfi_ztpmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ztpmv(ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ztpmv.html"},{"title":"mfi_stpsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_stpsv(ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_stpsv.html"},{"title":"mfi_dtpsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dtpsv(ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dtpsv.html"},{"title":"mfi_ctpsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ctpsv(ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ctpsv.html"},{"title":"mfi_ztpsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ztpsv(ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ztpsv.html"},{"title":"mfi_strmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_strmv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_strmv.html"},{"title":"mfi_dtrmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dtrmv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dtrmv.html"},{"title":"mfi_ctrmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ctrmv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ctrmv.html"},{"title":"mfi_ztrmv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ztrmv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ztrmv.html"},{"title":"mfi_strsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_strsv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_strsv.html"},{"title":"mfi_dtrsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dtrsv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_dtrsv.html"},{"title":"mfi_ctrsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ctrsv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ctrsv.html"},{"title":"mfi_ztrsv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ztrsv(a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"proc/mfi_ztrsv.html"},{"title":"mfi_sgemm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgemm(a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_sgemm.html"},{"title":"mfi_dgemm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgemm(a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_dgemm.html"},{"title":"mfi_cgemm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgemm(a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_cgemm.html"},{"title":"mfi_zgemm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgemm(a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_zgemm.html"},{"title":"mfi_chemm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_chemm(a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_chemm.html"},{"title":"mfi_zhemm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zhemm(a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_zhemm.html"},{"title":"mfi_cherk – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cherk(a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_cherk.html"},{"title":"mfi_zherk – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zherk(a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_zherk.html"},{"title":"mfi_cher2k – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cher2k(a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_cher2k.html"},{"title":"mfi_zher2k – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zher2k(a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_zher2k.html"},{"title":"mfi_ssymm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ssymm(a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_ssymm.html"},{"title":"mfi_dsymm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dsymm(a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_dsymm.html"},{"title":"mfi_ssyrk – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ssyrk(a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_ssyrk.html"},{"title":"mfi_dsyrk – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dsyrk(a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_dsyrk.html"},{"title":"mfi_ssyr2k – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ssyr2k(a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_ssyr2k.html"},{"title":"mfi_dsyr2k – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dsyr2k(a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"proc/mfi_dsyr2k.html"},{"title":"mfi_strmm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_strmm(a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha","tags":"","loc":"proc/mfi_strmm.html"},{"title":"mfi_dtrmm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dtrmm(a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha","tags":"","loc":"proc/mfi_dtrmm.html"},{"title":"mfi_ctrmm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ctrmm(a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha","tags":"","loc":"proc/mfi_ctrmm.html"},{"title":"mfi_ztrmm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ztrmm(a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha","tags":"","loc":"proc/mfi_ztrmm.html"},{"title":"mfi_strsm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_strsm(a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha","tags":"","loc":"proc/mfi_strsm.html"},{"title":"mfi_dtrsm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dtrsm(a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha","tags":"","loc":"proc/mfi_dtrsm.html"},{"title":"mfi_ctrsm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ctrsm(a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha","tags":"","loc":"proc/mfi_ctrsm.html"},{"title":"mfi_ztrsm – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_ztrsm(a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha","tags":"","loc":"proc/mfi_ztrsm.html"},{"title":"mfi_asum – MFI - Modern Fortran Interfaces","text":"public interface mfi_asum Module Procedures public pure function mfi_sasum (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dasum (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_scasum (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dzasum (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"interface/mfi_asum.html"},{"title":"mfi_nrm2 – MFI - Modern Fortran Interfaces","text":"public interface mfi_nrm2 Module Procedures public pure function mfi_snrm2 (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dnrm2 (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_scnrm2 (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dznrm2 (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp)","tags":"","loc":"interface/mfi_nrm2.html"},{"title":"mfi_axpy – MFI - Modern Fortran Interfaces","text":"public interface mfi_axpy Module Procedures public pure subroutine mfi_saxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_daxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_caxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zaxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_axpy.html"},{"title":"mfi_copy – MFI - Modern Fortran Interfaces","text":"public interface mfi_copy Module Procedures public pure subroutine mfi_scopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dcopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_ccopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zcopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_copy.html"},{"title":"mfi_dot – MFI - Modern Fortran Interfaces","text":"public interface mfi_dot Module Procedures public pure function mfi_sdot (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value real(kind=wp) public pure function mfi_ddot (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value real(kind=wp)","tags":"","loc":"interface/mfi_dot.html"},{"title":"mfi_dotu – MFI - Modern Fortran Interfaces","text":"public interface mfi_dotu Module Procedures public pure function mfi_cdotu (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public pure function mfi_zdotu (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp)","tags":"","loc":"interface/mfi_dotu.html"},{"title":"mfi_dotc – MFI - Modern Fortran Interfaces","text":"public interface mfi_dotc Module Procedures public pure function mfi_cdotc (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public pure function mfi_zdotc (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp)","tags":"","loc":"interface/mfi_dotc.html"},{"title":"mfi_rot – MFI - Modern Fortran Interfaces","text":"public interface mfi_rot Module Procedures public pure subroutine mfi_srot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_drot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_crot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_csrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zdrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_rot.html"},{"title":"mfi_rotm – MFI - Modern Fortran Interfaces","text":"public interface mfi_rotm Module Procedures public pure subroutine mfi_srotm (x, y, param, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: param (5) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_drotm (x, y, param, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: param (5) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_rotm.html"},{"title":"mfi_scal – MFI - Modern Fortran Interfaces","text":"public interface mfi_scal Module Procedures public pure subroutine mfi_sscal (x, a, incx) MFI_SSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_dscal (x, a, incx) MFI_DSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_cscal (x, a, incx) MFI_CSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_zscal (x, a, incx) MFI_ZSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_csscal (x, a, incx) MFI_CSSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_zdscal (x, a, incx) MFI_ZDSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_scal.html"},{"title":"mfi_swap – MFI - Modern Fortran Interfaces","text":"public interface mfi_swap Module Procedures public pure subroutine mfi_sswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_swap.html"},{"title":"mfi_gbmv – MFI - Modern Fortran Interfaces","text":"public interface mfi_gbmv Module Procedures public pure subroutine mfi_sgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_gbmv.html"},{"title":"mfi_gemv – MFI - Modern Fortran Interfaces","text":"public interface mfi_gemv Module Procedures public pure subroutine mfi_sgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_gemv.html"},{"title":"mfi_ger – MFI - Modern Fortran Interfaces","text":"public interface mfi_ger Module Procedures public pure subroutine mfi_sger (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dger (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_ger.html"},{"title":"mfi_gerc – MFI - Modern Fortran Interfaces","text":"public interface mfi_gerc Module Procedures public pure subroutine mfi_cgerc (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgerc (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_gerc.html"},{"title":"mfi_geru – MFI - Modern Fortran Interfaces","text":"public interface mfi_geru Module Procedures public pure subroutine mfi_cgeru (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgeru (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_geru.html"},{"title":"mfi_hbmv – MFI - Modern Fortran Interfaces","text":"public interface mfi_hbmv Module Procedures public pure subroutine mfi_chbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_hbmv.html"},{"title":"mfi_hemv – MFI - Modern Fortran Interfaces","text":"public interface mfi_hemv Module Procedures public pure subroutine mfi_chemv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhemv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_hemv.html"},{"title":"mfi_her – MFI - Modern Fortran Interfaces","text":"public interface mfi_her Module Procedures public pure subroutine mfi_cher (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_zher (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_her.html"},{"title":"mfi_her2 – MFI - Modern Fortran Interfaces","text":"public interface mfi_her2 Module Procedures public pure subroutine mfi_cher2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zher2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_her2.html"},{"title":"mfi_hpmv – MFI - Modern Fortran Interfaces","text":"public interface mfi_hpmv Module Procedures public pure subroutine mfi_chpmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhpmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_hpmv.html"},{"title":"mfi_hpr – MFI - Modern Fortran Interfaces","text":"public interface mfi_hpr Module Procedures public pure subroutine mfi_chpr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_zhpr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_hpr.html"},{"title":"mfi_hpr2 – MFI - Modern Fortran Interfaces","text":"public interface mfi_hpr2 Module Procedures public pure subroutine mfi_chpr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhpr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_hpr2.html"},{"title":"mfi_sbmv – MFI - Modern Fortran Interfaces","text":"public interface mfi_sbmv Module Procedures public pure subroutine mfi_ssbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_sbmv.html"},{"title":"mfi_spmv – MFI - Modern Fortran Interfaces","text":"public interface mfi_spmv Module Procedures public pure subroutine mfi_sspmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dspmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_spmv.html"},{"title":"mfi_spr – MFI - Modern Fortran Interfaces","text":"public interface mfi_spr Module Procedures public pure subroutine mfi_sspr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_dspr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_spr.html"},{"title":"mfi_spr2 – MFI - Modern Fortran Interfaces","text":"public interface mfi_spr2 Module Procedures public pure subroutine mfi_sspr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dspr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_spr2.html"},{"title":"mfi_symv – MFI - Modern Fortran Interfaces","text":"public interface mfi_symv Module Procedures public pure subroutine mfi_ssymv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsymv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_symv.html"},{"title":"mfi_syr – MFI - Modern Fortran Interfaces","text":"public interface mfi_syr Module Procedures public pure subroutine mfi_ssyr (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_dsyr (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_syr.html"},{"title":"mfi_syr2 – MFI - Modern Fortran Interfaces","text":"public interface mfi_syr2 Module Procedures public pure subroutine mfi_ssyr2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsyr2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy","tags":"","loc":"interface/mfi_syr2.html"},{"title":"mfi_tbmv – MFI - Modern Fortran Interfaces","text":"public interface mfi_tbmv Module Procedures public pure subroutine mfi_stbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_tbmv.html"},{"title":"mfi_tbsv – MFI - Modern Fortran Interfaces","text":"public interface mfi_tbsv Module Procedures public pure subroutine mfi_stbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_tbsv.html"},{"title":"mfi_tpmv – MFI - Modern Fortran Interfaces","text":"public interface mfi_tpmv Module Procedures public pure subroutine mfi_stpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_tpmv.html"},{"title":"mfi_tpsv – MFI - Modern Fortran Interfaces","text":"public interface mfi_tpsv Module Procedures public pure subroutine mfi_stpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_tpsv.html"},{"title":"mfi_trmv – MFI - Modern Fortran Interfaces","text":"public interface mfi_trmv Module Procedures public pure subroutine mfi_strmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_trmv.html"},{"title":"mfi_trsv – MFI - Modern Fortran Interfaces","text":"public interface mfi_trsv Module Procedures public pure subroutine mfi_strsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx","tags":"","loc":"interface/mfi_trsv.html"},{"title":"mfi_gemm – MFI - Modern Fortran Interfaces","text":"public interface mfi_gemm Module Procedures public pure subroutine mfi_sgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_cgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta","tags":"","loc":"interface/mfi_gemm.html"},{"title":"mfi_hemm – MFI - Modern Fortran Interfaces","text":"public interface mfi_hemm Module Procedures public pure subroutine mfi_chemm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zhemm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta","tags":"","loc":"interface/mfi_hemm.html"},{"title":"mfi_herk – MFI - Modern Fortran Interfaces","text":"public interface mfi_herk Module Procedures public pure subroutine mfi_cherk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zherk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"interface/mfi_herk.html"},{"title":"mfi_her2k – MFI - Modern Fortran Interfaces","text":"public interface mfi_her2k Module Procedures public pure subroutine mfi_cher2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zher2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"interface/mfi_her2k.html"},{"title":"mfi_symm – MFI - Modern Fortran Interfaces","text":"public interface mfi_symm Module Procedures public pure subroutine mfi_ssymm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsymm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"interface/mfi_symm.html"},{"title":"mfi_syrk – MFI - Modern Fortran Interfaces","text":"public interface mfi_syrk Module Procedures public pure subroutine mfi_ssyrk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsyrk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"interface/mfi_syrk.html"},{"title":"mfi_syr2k – MFI - Modern Fortran Interfaces","text":"public interface mfi_syr2k Module Procedures public pure subroutine mfi_ssyr2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsyr2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta","tags":"","loc":"interface/mfi_syr2k.html"},{"title":"mfi_trmm – MFI - Modern Fortran Interfaces","text":"public interface mfi_trmm Module Procedures public pure subroutine mfi_strmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_dtrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ctrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ztrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha","tags":"","loc":"interface/mfi_trmm.html"},{"title":"mfi_trsm – MFI - Modern Fortran Interfaces","text":"public interface mfi_trsm Module Procedures public pure subroutine mfi_strsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_dtrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ctrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ztrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha","tags":"","loc":"interface/mfi_trsm.html"},{"title":"mfi_iamax – MFI - Modern Fortran Interfaces","text":"public interface mfi_iamax Module Procedures public pure function mfi_isamax (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_idamax (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_icamax (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_izamax (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"interface/mfi_iamax.html"},{"title":"mfi_iamin – MFI - Modern Fortran Interfaces","text":"public interface mfi_iamin Module Procedures public pure function mfi_isamin (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_idamin (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_icamin (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_izamin (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer","tags":"","loc":"interface/mfi_iamin.html"},{"title":"mfi_lamch – MFI - Modern Fortran Interfaces","text":"public interface mfi_lamch Module Procedures public pure function mfi_slamch (cmach, kind) result(res) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach real(kind=wp), intent(in) :: kind Just a kind placeholder Return Value real(kind=wp) public pure function mfi_dlamch (cmach, kind) result(res) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach real(kind=wp), intent(in) :: kind Just a kind placeholder Return Value real(kind=wp)","tags":"","loc":"interface/mfi_lamch.html"},{"title":"mfi_sgeqrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgeqrf(a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_sgeqrf.html"},{"title":"mfi_dgeqrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgeqrf(a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_dgeqrf.html"},{"title":"mfi_cgeqrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgeqrf(a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cgeqrf.html"},{"title":"mfi_zgeqrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgeqrf(a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zgeqrf.html"},{"title":"mfi_sgerqf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgerqf(a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_sgerqf.html"},{"title":"mfi_dgerqf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgerqf(a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_dgerqf.html"},{"title":"mfi_cgerqf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgerqf(a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cgerqf.html"},{"title":"mfi_zgerqf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgerqf(a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zgerqf.html"},{"title":"mfi_sgetrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgetrf(a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_sgetrf.html"},{"title":"mfi_dgetrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgetrf(a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_dgetrf.html"},{"title":"mfi_cgetrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgetrf(a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cgetrf.html"},{"title":"mfi_zgetrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgetrf(a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zgetrf.html"},{"title":"mfi_sgetri – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgetri(a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_sgetri.html"},{"title":"mfi_dgetri – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgetri(a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_dgetri.html"},{"title":"mfi_cgetri – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgetri(a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cgetri.html"},{"title":"mfi_zgetri – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgetri(a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zgetri.html"},{"title":"mfi_sgetrs – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgetrs(a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_sgetrs.html"},{"title":"mfi_dgetrs – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgetrs(a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_dgetrs.html"},{"title":"mfi_cgetrs – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgetrs(a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cgetrs.html"},{"title":"mfi_zgetrs – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgetrs(a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zgetrs.html"},{"title":"mfi_chetrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_chetrf(a, uplo, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_chetrf.html"},{"title":"mfi_zhetrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zhetrf(a, uplo, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zhetrf.html"},{"title":"mfi_chegv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_chegv(a, b, w, itype, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) real(kind=wp), intent(out) :: w (:) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_chegv.html"},{"title":"mfi_zhegv – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zhegv(a, b, w, itype, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) real(kind=wp), intent(out) :: w (:) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zhegv.html"},{"title":"mfi_cheevd – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cheevd(a, w, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: w (:) character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cheevd.html"},{"title":"mfi_zheevd – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zheevd(a, w, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: w (:) character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zheevd.html"},{"title":"mfi_sgesvd – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_sgesvd(a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) real(kind=wp), intent(out), optional, target :: u (:,:) real(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_sgesvd.html"},{"title":"mfi_dgesvd – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dgesvd(a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) real(kind=wp), intent(out), optional, target :: u (:,:) real(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_dgesvd.html"},{"title":"mfi_cgesvd – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cgesvd(a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) complex(kind=wp), intent(out), optional, target :: u (:,:) complex(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cgesvd.html"},{"title":"mfi_zgesvd – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zgesvd(a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) complex(kind=wp), intent(out), optional, target :: u (:,:) complex(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zgesvd.html"},{"title":"mfi_spotrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_spotrf(a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"proc/mfi_spotrf.html"},{"title":"mfi_dpotrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dpotrf(a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"proc/mfi_dpotrf.html"},{"title":"mfi_cpotrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cpotrf(a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"proc/mfi_cpotrf.html"},{"title":"mfi_zpotrf – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zpotrf(a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"proc/mfi_zpotrf.html"},{"title":"mfi_spotri – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_spotri(a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"proc/mfi_spotri.html"},{"title":"mfi_dpotri – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dpotri(a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"proc/mfi_dpotri.html"},{"title":"mfi_cpotri – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cpotri(a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"proc/mfi_cpotri.html"},{"title":"mfi_zpotri – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zpotri(a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"proc/mfi_zpotri.html"},{"title":"mfi_spotrs – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_spotrs(a, b, uplo, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_spotrs.html"},{"title":"mfi_dpotrs – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dpotrs(a, b, uplo, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_dpotrs.html"},{"title":"mfi_cpotrs – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cpotrs(a, b, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cpotrs.html"},{"title":"mfi_zpotrs – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zpotrs(a, b, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zpotrs.html"},{"title":"mfi_spocon – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_spocon(a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_spocon.html"},{"title":"mfi_dpocon – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_dpocon(a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_dpocon.html"},{"title":"mfi_cpocon – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_cpocon(a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_cpocon.html"},{"title":"mfi_zpocon – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_zpocon(a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"proc/mfi_zpocon.html"},{"title":"mfi_error – MFI - Modern Fortran Interfaces","text":"public pure subroutine mfi_error(name, info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name integer, intent(in) :: info","tags":"","loc":"proc/mfi_error.html"},{"title":"mfi_geqrf – MFI - Modern Fortran Interfaces","text":"public interface mfi_geqrf Module Procedures public pure subroutine mfi_sgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_dgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_cgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_zgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_geqrf.html"},{"title":"mfi_gerqf – MFI - Modern Fortran Interfaces","text":"public interface mfi_gerqf Module Procedures public pure subroutine mfi_sgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_dgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_cgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_zgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_gerqf.html"},{"title":"mfi_getrf – MFI - Modern Fortran Interfaces","text":"public interface mfi_getrf Module Procedures public pure subroutine mfi_sgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_dgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_cgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_getrf.html"},{"title":"mfi_getri – MFI - Modern Fortran Interfaces","text":"public interface mfi_getri Module Procedures public pure subroutine mfi_sgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_dgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_cgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_getri.html"},{"title":"mfi_getrs – MFI - Modern Fortran Interfaces","text":"public interface mfi_getrs Module Procedures public pure subroutine mfi_sgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_dgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_cgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_zgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_getrs.html"},{"title":"mfi_hetrf – MFI - Modern Fortran Interfaces","text":"public interface mfi_hetrf Module Procedures public pure subroutine mfi_chetrf (a, uplo, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zhetrf (a, uplo, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_hetrf.html"},{"title":"mfi_hegv – MFI - Modern Fortran Interfaces","text":"public interface mfi_hegv Module Procedures public pure subroutine mfi_chegv (a, b, w, itype, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) real(kind=wp), intent(out) :: w (:) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zhegv (a, b, w, itype, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) real(kind=wp), intent(out) :: w (:) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_hegv.html"},{"title":"mfi_heevd – MFI - Modern Fortran Interfaces","text":"public interface mfi_heevd Module Procedures public pure subroutine mfi_cheevd (a, w, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: w (:) character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zheevd (a, w, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: w (:) character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_heevd.html"},{"title":"mfi_gesvd – MFI - Modern Fortran Interfaces","text":"public interface mfi_gesvd Module Procedures public pure subroutine mfi_sgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) real(kind=wp), intent(out), optional, target :: u (:,:) real(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_dgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) real(kind=wp), intent(out), optional, target :: u (:,:) real(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_cgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) complex(kind=wp), intent(out), optional, target :: u (:,:) complex(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_zgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) complex(kind=wp), intent(out), optional, target :: u (:,:) complex(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_gesvd.html"},{"title":"mfi_potrf – MFI - Modern Fortran Interfaces","text":"public interface mfi_potrf Module Procedures public pure subroutine mfi_spotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_dpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_cpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_zpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"interface/mfi_potrf.html"},{"title":"mfi_potri – MFI - Modern Fortran Interfaces","text":"public interface mfi_potri Module Procedures public pure subroutine mfi_spotri (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_dpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_cpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_zpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo","tags":"","loc":"interface/mfi_potri.html"},{"title":"mfi_potrs – MFI - Modern Fortran Interfaces","text":"public interface mfi_potrs Module Procedures public pure subroutine mfi_spotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_dpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_cpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_potrs.html"},{"title":"mfi_pocon – MFI - Modern Fortran Interfaces","text":"public interface mfi_pocon Module Procedures public pure subroutine mfi_spocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_dpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_cpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info","tags":"","loc":"interface/mfi_pocon.html"},{"title":"f77_lapack – MFI - Modern Fortran Interfaces","text":"Improved and original F77 interfaces for LAPACK Uses iso_fortran_env Interfaces interface public pure subroutine sgeqrf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: tau (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine dgeqrf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: tau (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine cgeqrf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(out) :: tau (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine zgeqrf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(out) :: tau (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info public        interface f77_geqrf public  interface sgeqrf () Arguments None public  interface dgeqrf () Arguments None public  interface cgeqrf () Arguments None public  interface zgeqrf () Arguments None interface public pure subroutine sgerqf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: tau (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine dgerqf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: tau (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine cgerqf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(out) :: tau (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine zgerqf(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(out) :: tau (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info public        interface f77_gerqf public  interface sgerqf () Arguments None public  interface dgerqf () Arguments None public  interface cgerqf () Arguments None public  interface zgerqf () Arguments None interface public pure subroutine sgetrf(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) integer, intent(out) :: info interface public pure subroutine dgetrf(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) integer, intent(out) :: info interface public pure subroutine cgetrf(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) integer, intent(out) :: info interface public pure subroutine zgetrf(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) integer, intent(out) :: info public        interface f77_getrf public  interface sgetrf () Arguments None public  interface dgetrf () Arguments None public  interface cgetrf () Arguments None public  interface zgetrf () Arguments None interface public pure subroutine sgetri(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine dgetri(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine cgetri(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine zgetri(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info public        interface f77_getri public  interface sgetri () Arguments None public  interface dgetri () Arguments None public  interface cgetri () Arguments None public  interface zgetri () Arguments None interface public pure subroutine sgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: nrhs real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info interface public pure subroutine dgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: nrhs real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info interface public pure subroutine cgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info interface public pure subroutine zgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info public        interface f77_getrs public  interface sgetrs () Arguments None public  interface dgetrs () Arguments None public  interface cgetrs () Arguments None public  interface zgetrs () Arguments None interface public pure subroutine chetrf(uplo, n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine zhetrf(uplo, n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(in) :: ipiv (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info public        interface f77_hetrf public  interface chetrf () Arguments None public  interface zhetrf () Arguments None interface public pure subroutine chegv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: itype character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(in) :: rwork (*) integer, intent(out) :: info interface public pure subroutine zhegv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: itype character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(in) :: rwork (*) integer, intent(out) :: info public        interface f77_hegv public  interface chegv () Arguments None public  interface zhegv () Arguments None interface public pure subroutine cheevd(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info interface public pure subroutine zheevd(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info public        interface f77_heevd public  interface cheevd () Arguments None public  interface zheevd () Arguments None interface public pure subroutine cheevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, ifail, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: range character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: vl real(kind=wp), intent(in) :: vu integer, intent(in) :: il integer, intent(in) :: iu real(kind=wp), intent(in) :: abstol integer, intent(in) :: m real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: z (ldz,*) integer, intent(in) :: ldz complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(in) :: ifail integer, intent(out) :: info interface public pure subroutine zheevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, ifail, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: range character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: vl real(kind=wp), intent(in) :: vu integer, intent(in) :: il integer, intent(in) :: iu real(kind=wp), intent(in) :: abstol integer, intent(in) :: m real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: z (ldz,*) integer, intent(in) :: ldz complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(in) :: ifail integer, intent(out) :: info public        interface f77_heevx public  interface cheevx () Arguments None public  interface zheevx () Arguments None interface public pure subroutine cheevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: range character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: vl real(kind=wp), intent(in) :: vu integer, intent(in) :: il integer, intent(in) :: iu real(kind=wp), intent(in) :: abstol integer, intent(in) :: m real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: z (ldz,*) integer, intent(in) :: ldz integer, intent(in) :: isuppz (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info interface public pure subroutine zheevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: range character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: vl real(kind=wp), intent(in) :: vu integer, intent(in) :: il integer, intent(in) :: iu real(kind=wp), intent(in) :: abstol integer, intent(in) :: m real(kind=wp), intent(out) :: w (*) complex(kind=wp), intent(inout) :: z (ldz,*) integer, intent(in) :: ldz integer, intent(in) :: isuppz (*) complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(inout) :: rwork (*) integer, intent(in) :: lrwork integer, intent(inout) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info public        interface f77_heevr public  interface cheevr () Arguments None public  interface zheevr () Arguments None interface public pure subroutine sgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: s (*) real(kind=wp), intent(out) :: u (ldu,*) integer, intent(in) :: ldu real(kind=wp), intent(out) :: vt (ldvt,*) integer, intent(in) :: ldvt real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine dgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: s (*) real(kind=wp), intent(out) :: u (ldu,*) integer, intent(in) :: ldu real(kind=wp), intent(out) :: vt (ldvt,*) integer, intent(in) :: ldvt real(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info interface public pure subroutine cgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: s (*) complex(kind=wp), intent(out) :: u (ldu,*) integer, intent(in) :: ldu complex(kind=wp), intent(out) :: vt (ldvt,*) integer, intent(in) :: ldvt complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(in) :: rwork (*) integer, intent(out) :: info interface public pure subroutine zgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(out) :: s (*) complex(kind=wp), intent(out) :: u (ldu,*) integer, intent(in) :: ldu complex(kind=wp), intent(out) :: vt (ldvt,*) integer, intent(in) :: ldvt complex(kind=wp), intent(inout) :: work (*) integer, intent(in) :: lwork real(kind=wp), intent(in) :: rwork (*) integer, intent(out) :: info public        interface f77_gesvd public  interface sgesvd () Arguments None public  interface dgesvd () Arguments None public  interface cgesvd () Arguments None public  interface zgesvd () Arguments None interface public pure subroutine spotrf(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info interface public pure subroutine dpotrf(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info interface public pure subroutine cpotrf(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info interface public pure subroutine zpotrf(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info public        interface f77_potrf public  interface spotrf () Arguments None public  interface dpotrf () Arguments None public  interface cpotrf () Arguments None public  interface zpotrf () Arguments None interface public pure subroutine spotri(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info interface public pure subroutine dpotri(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info interface public pure subroutine cpotri(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info interface public pure subroutine zpotri(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: info public        interface f77_potri public  interface spotri () Arguments None public  interface dpotri () Arguments None public  interface cpotri () Arguments None public  interface zpotri () Arguments None interface public pure subroutine spotrs(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: nrhs real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info interface public pure subroutine dpotrs(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: nrhs real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info interface public pure subroutine cpotrs(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info interface public pure subroutine zpotrs(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info public        interface f77_potrs public  interface spotrs () Arguments None public  interface dpotrs () Arguments None public  interface cpotrs () Arguments None public  interface zpotrs () Arguments None interface public pure subroutine spocon(uplo, n, a, lda, anorm, rcond, work, iwork, info) spocon estimates the reciprocal of the condition number (in the\n1-norm) of a real(REAL32) Hermitian positive definite matrix using the\nCholesky factorization A = U H U or A = L L H computed by sPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond real(kind=wp), intent(inout) :: work (*) integer, intent(inout) :: iwork (*) integer, intent(out) :: info interface public pure subroutine dpocon(uplo, n, a, lda, anorm, rcond, work, iwork, info) dpocon estimates the reciprocal of the condition number (in the\n1-norm) of a real(REAL64) Hermitian positive definite matrix using the\nCholesky factorization A = U H U or A = L L H computed by dPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond real(kind=wp), intent(inout) :: work (*) integer, intent(inout) :: iwork (*) integer, intent(out) :: info interface public pure subroutine cpocon(uplo, n, a, lda, anorm, rcond, work, rwork, info) cpocon estimates the reciprocal of the condition number (in the\n1-norm) of a complex(REAL32) Hermitian positive definite matrix using the\nCholesky factorization A = U H U or A = L L H computed by cPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond complex(kind=wp), intent(inout) :: work (*) real(kind=wp), intent(inout) :: rwork (*) integer, intent(out) :: info interface public pure subroutine zpocon(uplo, n, a, lda, anorm, rcond, work, rwork, info) zpocon estimates the reciprocal of the condition number (in the\n1-norm) of a complex(REAL64) Hermitian positive definite matrix using the\nCholesky factorization A = U H U or A = L L H computed by zPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond complex(kind=wp), intent(inout) :: work (*) real(kind=wp), intent(inout) :: rwork (*) integer, intent(out) :: info public        interface f77_pocon public  interface spocon () Arguments None public  interface dpocon () Arguments None public  interface cpocon () Arguments None public  interface zpocon () Arguments None interface public pure subroutine slartg(f, g, c, s, r) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: f real(kind=wp), intent(inout) :: g real(kind=wp), intent(inout) :: c real(kind=wp), intent(inout) :: s real(kind=wp), intent(inout) :: r interface public pure subroutine dlartg(f, g, c, s, r) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: f real(kind=wp), intent(inout) :: g real(kind=wp), intent(inout) :: c real(kind=wp), intent(inout) :: s real(kind=wp), intent(inout) :: r interface public pure subroutine clartg(f, g, c, s, r) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: f complex(kind=wp), intent(inout) :: g real(kind=wp), intent(inout) :: c complex(kind=wp), intent(inout) :: s complex(kind=wp), intent(inout) :: r interface public pure subroutine zlartg(f, g, c, s, r) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: f complex(kind=wp), intent(inout) :: g real(kind=wp), intent(inout) :: c complex(kind=wp), intent(inout) :: s complex(kind=wp), intent(inout) :: r public        interface f77_lartg public  interface slartg () Arguments None public  interface dlartg () Arguments None public  interface clartg () Arguments None public  interface zlartg () Arguments None public        interface f77_xerbla public pure subroutine xerbla(name, info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name integer, intent(in) :: info","tags":"","loc":"module/f77_lapack.html"},{"title":"f77_blas – MFI - Modern Fortran Interfaces","text":"Improved and original F77 interfaces for blas Uses iso_fortran_env Interfaces interface public pure subroutine saxpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine daxpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine caxpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: a complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine zaxpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: a complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_axpy public  interface saxpy () Arguments None public  interface daxpy () Arguments None public  interface caxpy () Arguments None public  interface zaxpy () Arguments None interface public pure subroutine scopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine dcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine ccopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine zcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_copy public  interface scopy () Arguments None public  interface dcopy () Arguments None public  interface ccopy () Arguments None public  interface zcopy () Arguments None interface public pure function sdot(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value real(kind=wp) interface public pure function ddot(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value real(kind=wp) public        interface f77_dot public  interface sdot () Arguments None public  interface ddot () Arguments None interface public pure function cdotu(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value complex(kind=wp) interface public pure function zdotu(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value complex(kind=wp) public        interface f77_dotu public  interface cdotu () Arguments None public  interface zdotu () Arguments None interface public pure function cdotc(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value complex(kind=wp) interface public pure function zdotc(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy Return Value complex(kind=wp) public        interface f77_dotc public  interface cdotc () Arguments None public  interface zdotc () Arguments None interface public pure subroutine srotg(a, b, c, s) srotg generates a Givens rotation with real cosine and complex sine: [ c s ] [ a ] = [ r ] [ - s c ] [ b ] [ 0 ] satisfying c**2 + s**2 = 1 . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s interface public pure subroutine drotg(a, b, c, s) drotg generates a Givens rotation with real cosine and complex sine: [ c s ] [ a ] = [ r ] [ - s c ] [ b ] [ 0 ] satisfying c**2 + s**2 = 1 . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s interface public pure subroutine crotg(a, b, c, s) crotg generates a Givens rotation with real cosine and complex sine: [ c s ] [ a ] = [ r ] [ - conjg ( s ) c ] [ b ] [ 0 ] where c is real, s is complex, and c**2 + conjg(s)*s = 1 . Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a complex(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c complex(kind=wp), intent(out) :: s interface public pure subroutine zrotg(a, b, c, s) zrotg generates a Givens rotation with real cosine and complex sine: [ c s ] [ a ] = [ r ] [ - conjg ( s ) c ] [ b ] [ 0 ] where c is real, s is complex, and c**2 + conjg(s)*s = 1 . Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a complex(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c complex(kind=wp), intent(out) :: s public        interface f77_rotg public  interface srotg () Arguments None public  interface drotg () Arguments None public  interface crotg () Arguments None public  interface zrotg () Arguments None interface public pure subroutine srotm(n, x, incx, y, incy, param) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: param (5) interface public pure subroutine drotm(n, x, incx, y, incy, param) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: param (5) public        interface f77_rotm public  interface srotm () Arguments None public  interface drotm () Arguments None interface public pure subroutine srotmg(d1, d2, x1, y1, param) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: d1 real(kind=wp), intent(inout) :: d2 real(kind=wp), intent(inout) :: x1 real(kind=wp), intent(in) :: y1 real(kind=wp), intent(out) :: param (5) interface public pure subroutine drotmg(d1, d2, x1, y1, param) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: d1 real(kind=wp), intent(inout) :: d2 real(kind=wp), intent(inout) :: x1 real(kind=wp), intent(in) :: y1 real(kind=wp), intent(out) :: param (5) public        interface f77_rotmg public  interface srotmg () Arguments None public  interface drotmg () Arguments None interface public pure subroutine sswap(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine dswap(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine cswap(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine zswap(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_swap public  interface sswap () Arguments None public  interface dswap () Arguments None public  interface cswap () Arguments None public  interface zswap () Arguments None interface public pure function sasum(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) interface public pure function dasum(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) interface public pure function scasum(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) interface public pure function dzasum(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) public        interface f77_asum public  interface sasum () Arguments None public  interface dasum () Arguments None public  interface scasum () Arguments None public  interface dzasum () Arguments None interface public pure function snrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) interface public pure function dnrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) interface public pure function scnrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) interface public pure function dznrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) public        interface f77_nrm2 public  interface snrm2 () Arguments None public  interface dnrm2 () Arguments None public  interface scnrm2 () Arguments None public  interface dznrm2 () Arguments None interface public pure subroutine sscal(n, a, x, incx) SSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine dscal(n, a, x, incx) DSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine cscal(n, a, x, incx) CSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: a complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine zscal(n, a, x, incx) ZSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: a complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine csscal(n, a, x, incx) CSSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine zdscal(n, a, x, incx) ZDSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: a complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx public        interface f77_scal public  interface sscal () Arguments None public  interface dscal () Arguments None public  interface cscal () Arguments None public  interface zscal () Arguments None public  interface csscal () Arguments None public  interface zdscal () Arguments None interface public pure subroutine srot(n, x, incx, y, incy, c, s) SROT applies a plane rotation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s interface public pure subroutine drot(n, x, incx, y, incy, c, s) DROT applies a plane rotation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s interface public pure subroutine crot(n, x, incx, y, incy, c, s) CROT applies a plane rotation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s interface public pure subroutine zrot(n, x, incx, y, incy, c, s) ZROT applies a plane rotation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s interface public pure subroutine csrot(n, x, incx, y, incy, c, s) CSROT applies a plane rotation,\nwhere the cos and sin (c and s) are real\nand the vectors x and y are complex. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s interface public pure subroutine zdrot(n, x, incx, y, incy, c, s) ZDROT applies a plane rotation,\nwhere the cos and sin (c and s) are real\nand the vectors x and y are complex. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s public        interface f77_rot public  interface srot () Arguments None public  interface drot () Arguments None public  interface crot () Arguments None public  interface zrot () Arguments None public  interface csrot () Arguments None public  interface zdrot () Arguments None interface public pure subroutine sgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine dgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine cgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine zgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_gbmv public  interface sgbmv () Arguments None public  interface dgbmv () Arguments None public  interface cgbmv () Arguments None public  interface zgbmv () Arguments None interface public pure subroutine sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine cgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine zgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_gemv public  interface sgemv () Arguments None public  interface dgemv () Arguments None public  interface cgemv () Arguments None public  interface zgemv () Arguments None interface public pure subroutine sger(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda interface public pure subroutine dger(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda public        interface f77_ger public  interface sger () Arguments None public  interface dger () Arguments None interface public pure subroutine cgerc(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda interface public pure subroutine zgerc(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda public        interface f77_gerc public  interface cgerc () Arguments None public  interface zgerc () Arguments None interface public pure subroutine cgeru(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda interface public pure subroutine zgeru(m, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda public        interface f77_geru public  interface cgeru () Arguments None public  interface zgeru () Arguments None interface public pure subroutine chbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine zhbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_hbmv public  interface chbmv () Arguments None public  interface zhbmv () Arguments None interface public pure subroutine chemv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine zhemv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_hemv public  interface chemv () Arguments None public  interface zhemv () Arguments None interface public pure subroutine cher(uplo, n, alpha, x, incx, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda interface public pure subroutine zher(uplo, n, alpha, x, incx, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda public        interface f77_her public  interface cher () Arguments None public  interface zher () Arguments None interface public pure subroutine cher2(uplo, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda interface public pure subroutine zher2(uplo, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda public        interface f77_her2 public  interface cher2 () Arguments None public  interface zher2 () Arguments None interface public pure subroutine chpmv(uplo, n, alpha, ap, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine zhpmv(uplo, n, alpha, ap, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_hpmv public  interface chpmv () Arguments None public  interface zhpmv () Arguments None interface public pure subroutine chpr(uplo, n, alpha, x, incx, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: ap (*) interface public pure subroutine zhpr(uplo, n, alpha, x, incx, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(inout) :: ap (*) public        interface f77_hpr public  interface chpr () Arguments None public  interface zhpr () Arguments None interface public pure subroutine chpr2(uplo, n, alpha, x, incx, y, incy, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: ap (*) interface public pure subroutine zhpr2(uplo, n, alpha, x, incx, y, incy, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=wp), intent(inout) :: ap (*) public        interface f77_hpr2 public  interface chpr2 () Arguments None public  interface zhpr2 () Arguments None interface public pure subroutine ssbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine dsbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_sbmv public  interface ssbmv () Arguments None public  interface dsbmv () Arguments None interface public pure subroutine sspmv(uplo, n, alpha, ap, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine dspmv(uplo, n, alpha, ap, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_spmv public  interface sspmv () Arguments None public  interface dspmv () Arguments None interface public pure subroutine sspr(uplo, n, alpha, x, incx, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: ap (*) interface public pure subroutine dspr(uplo, n, alpha, x, incx, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: ap (*) public        interface f77_spr public  interface sspr () Arguments None public  interface dspr () Arguments None interface public pure subroutine sspr2(uplo, n, alpha, x, incx, y, incy, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: ap (*) interface public pure subroutine dspr2(uplo, n, alpha, x, incx, y, incy, ap) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: ap (*) public        interface f77_spr2 public  interface sspr2 () Arguments None public  interface dspr2 () Arguments None interface public pure subroutine ssymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy interface public pure subroutine dsymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: y (*) integer, intent(in) :: incy public        interface f77_symv public  interface ssymv () Arguments None public  interface dsymv () Arguments None interface public pure subroutine ssyr(uplo, n, alpha, x, incx, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda interface public pure subroutine dsyr(uplo, n, alpha, x, incx, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda public        interface f77_syr public  interface ssyr () Arguments None public  interface dsyr () Arguments None interface public pure subroutine ssyr2(uplo, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda interface public pure subroutine dsyr2(uplo, n, alpha, x, incx, y, incy, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: y (*) integer, intent(in) :: incy real(kind=wp), intent(inout) :: a (lda,*) integer, intent(in) :: lda public        interface f77_syr2 public  interface ssyr2 () Arguments None public  interface dsyr2 () Arguments None interface public pure subroutine stbmv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine dtbmv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ctbmv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ztbmv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx public        interface f77_tbmv public  interface stbmv () Arguments None public  interface dtbmv () Arguments None public  interface ctbmv () Arguments None public  interface ztbmv () Arguments None interface public pure subroutine stbsv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine dtbsv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ctbsv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ztbsv(uplo, trans, diag, n, k, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx public        interface f77_tbsv public  interface stbsv () Arguments None public  interface dtbsv () Arguments None public  interface ctbsv () Arguments None public  interface ztbsv () Arguments None interface public pure subroutine stpmv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine dtpmv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ctpmv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ztpmv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx public        interface f77_tpmv public  interface stpmv () Arguments None public  interface dtpmv () Arguments None public  interface ctpmv () Arguments None public  interface ztpmv () Arguments None interface public pure subroutine stpsv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine dtpsv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: ap (*) real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ctpsv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ztpsv(uplo, trans, diag, n, ap, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: ap (*) complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx public        interface f77_tpsv public  interface stpsv () Arguments None public  interface dtpsv () Arguments None public  interface ctpsv () Arguments None public  interface ztpsv () Arguments None interface public pure subroutine strmv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine dtrmv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ctrmv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ztrmv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx public        interface f77_trmv public  interface strmv () Arguments None public  interface dtrmv () Arguments None public  interface ctrmv () Arguments None public  interface ztrmv () Arguments None interface public pure subroutine strsv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine dtrsv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ctrsv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx interface public pure subroutine ztrsv(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: x (*) integer, intent(in) :: incx public        interface f77_trsv public  interface strsv () Arguments None public  interface dtrsv () Arguments None public  interface ctrsv () Arguments None public  interface ztrsv () Arguments None interface public pure subroutine sgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine cgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine zgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public        interface f77_gemm public  interface sgemm () Arguments None public  interface dgemm () Arguments None public  interface cgemm () Arguments None public  interface zgemm () Arguments None interface public pure subroutine chemm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine zhemm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public        interface f77_hemm public  interface chemm () Arguments None public  interface zhemm () Arguments None interface public pure subroutine cherk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine zherk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public        interface f77_herk public  interface cherk () Arguments None public  interface zherk () Arguments None interface public pure subroutine cher2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine zher2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta complex(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public        interface f77_her2k public  interface cher2k () Arguments None public  interface zher2k () Arguments None interface public pure subroutine ssymm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine dsymm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public        interface f77_symm public  interface ssymm () Arguments None public  interface dsymm () Arguments None interface public pure subroutine ssyrk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine dsyrk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public        interface f77_syrk public  interface ssyrk () Arguments None public  interface dsyrk () Arguments None interface public pure subroutine ssyr2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc interface public pure subroutine dsyr2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(in) :: b (ldb,*) integer, intent(in) :: ldb real(kind=wp), intent(in) :: beta real(kind=wp), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public        interface f77_syr2k public  interface ssyr2k () Arguments None public  interface dsyr2k () Arguments None interface public pure subroutine strmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb interface public pure subroutine dtrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb interface public pure subroutine ctrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb interface public pure subroutine ztrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public        interface f77_trmm public  interface strmm () Arguments None public  interface dtrmm () Arguments None public  interface ctrmm () Arguments None public  interface ztrmm () Arguments None interface public pure subroutine strsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb interface public pure subroutine dtrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda real(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb interface public pure subroutine ctrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb interface public pure subroutine ztrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=wp), intent(in) :: alpha complex(kind=wp), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=wp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public        interface f77_trsm public  interface strsm () Arguments None public  interface dtrsm () Arguments None public  interface ctrsm () Arguments None public  interface ztrsm () Arguments None interface public pure function slamch(cmach) SLAMCH determines single precision machine parameters. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach Return Value real(kind=real32) interface public pure function dlamch(cmach) DLAMCH determines double precision machine parameters. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach Return Value real(kind=real64) interface public pure function sdsdot(n, sb, sx, incx, sy, incy) Compute the inner product of two vectors with extended\nprecision accumulation. Returns S.P. result with dot product accumulated in D.P.\nSDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I INCX) SY(LY+I INCY),\nwhere LX = 1 if INCX .GE. 0, else LX = 1+(1-N) INCX, and LY is\ndefined in a similar way using INCY. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: sb real(kind=wp), intent(in) :: sx (*) integer, intent(in) :: incx real(kind=wp), intent(in) :: sy (*) integer, intent(in) :: incy Return Value real(kind=wp) interface public pure function dsdot(n, sx, incx, sy, incy) Compute the inner product of two vectors with extended\nprecision accumulation and result. Returns D.P. dot product accumulated in D.P., for S.P. SX and SY\nDSDOT = sum for I = 0 to N-1 of  SX(LX+I INCX) * SY(LY+I INCY),\nwhere LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is\ndefined in a similar way using INCY. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=sp), intent(in) :: sx (*) integer, intent(in) :: incx real(kind=sp), intent(in) :: sy (*) integer, intent(in) :: incy Return Value real(kind=dp) public        interface f77_iamax public pure function isamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function idamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function icamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function izamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public        interface f77_iamin public pure function isamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function idamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function icamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function izamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer Functions public pure function isamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function idamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function icamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function izamax (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function isamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function idamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function icamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer public pure function izamin (n, x, incx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value integer","tags":"","loc":"module/f77_blas.html"},{"title":"mfi_blas – MFI - Modern Fortran Interfaces","text":"Modern fortran interfaces for BLAS Uses f77_blas iso_fortran_env Interfaces public        interface mfi_asum public pure function mfi_sasum (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dasum (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_scasum (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dzasum (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public        interface mfi_nrm2 public pure function mfi_snrm2 (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dnrm2 (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_scnrm2 (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dznrm2 (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public        interface mfi_axpy public pure subroutine mfi_saxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_daxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_caxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zaxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_copy public pure subroutine mfi_scopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dcopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_ccopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zcopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_dot public pure function mfi_sdot (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value real(kind=wp) public pure function mfi_ddot (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value real(kind=wp) public        interface mfi_dotu public pure function mfi_cdotu (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public pure function mfi_zdotu (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public        interface mfi_dotc public pure function mfi_cdotc (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public pure function mfi_zdotc (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public        interface mfi_rot public pure subroutine mfi_srot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - s * xi Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_drot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - s * xi Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_crot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - conj ( s ) * xi Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - conj ( s ) * xi Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_csrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - conj ( s ) * xi Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zdrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: xi = c * xi + s * yi yi = c * yi - conj ( s ) * xi Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_rotm public pure subroutine mfi_srotm (x, y, param, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: param (5) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_drotm (x, y, param, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: param (5) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_scal public pure subroutine mfi_sscal (x, a, incx) MFI_SSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_dscal (x, a, incx) MFI_DSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_cscal (x, a, incx) MFI_CSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_zscal (x, a, incx) MFI_ZSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_csscal (x, a, incx) MFI_CSSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_zdscal (x, a, incx) MFI_ZDSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public        interface mfi_swap public pure subroutine mfi_sswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_gbmv public pure subroutine mfi_sgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_gemv public pure subroutine mfi_sgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_ger public pure subroutine mfi_sger (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dger (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_gerc public pure subroutine mfi_cgerc (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgerc (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_geru public pure subroutine mfi_cgeru (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgeru (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_hbmv public pure subroutine mfi_chbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_hemv public pure subroutine mfi_chemv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhemv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_her public pure subroutine mfi_cher (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_zher (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public        interface mfi_her2 public pure subroutine mfi_cher2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zher2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_hpmv public pure subroutine mfi_chpmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhpmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_hpr public pure subroutine mfi_chpr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_zhpr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public        interface mfi_hpr2 public pure subroutine mfi_chpr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhpr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_sbmv public pure subroutine mfi_ssbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_spmv public pure subroutine mfi_sspmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dspmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_spr public pure subroutine mfi_sspr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_dspr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public        interface mfi_spr2 public pure subroutine mfi_sspr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dspr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_symv public pure subroutine mfi_ssymv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsymv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_syr public pure subroutine mfi_ssyr (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_dsyr (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public        interface mfi_syr2 public pure subroutine mfi_ssyr2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsyr2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public        interface mfi_tbmv public pure subroutine mfi_stbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public        interface mfi_tbsv public pure subroutine mfi_stbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public        interface mfi_tpmv public pure subroutine mfi_stpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public        interface mfi_tpsv public pure subroutine mfi_stpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public        interface mfi_trmv public pure subroutine mfi_strmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public        interface mfi_trsv public pure subroutine mfi_strsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public        interface mfi_gemm public pure subroutine mfi_sgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_cgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public        interface mfi_hemm public pure subroutine mfi_chemm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zhemm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public        interface mfi_herk public pure subroutine mfi_cherk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zherk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public        interface mfi_her2k public pure subroutine mfi_cher2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zher2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public        interface mfi_symm public pure subroutine mfi_ssymm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsymm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public        interface mfi_syrk public pure subroutine mfi_ssyrk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsyrk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public        interface mfi_syr2k public pure subroutine mfi_ssyr2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsyr2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public        interface mfi_trmm public pure subroutine mfi_strmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_dtrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ctrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ztrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public        interface mfi_trsm public pure subroutine mfi_strsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_dtrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ctrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ztrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public        interface mfi_iamax public pure function mfi_isamax (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_idamax (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_icamax (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_izamax (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public        interface mfi_iamin public pure function mfi_isamin (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_idamin (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_icamin (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_izamin (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public        interface mfi_lamch public pure function mfi_slamch (cmach, kind) result(res) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach real(kind=wp), intent(in) :: kind Just a kind placeholder Return Value real(kind=wp) public pure function mfi_dlamch (cmach, kind) result(res) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach real(kind=wp), intent(in) :: kind Just a kind placeholder Return Value real(kind=wp) Functions public pure function mfi_snrm2 (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dnrm2 (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_scnrm2 (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dznrm2 (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_sasum (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dasum (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_scasum (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_dzasum (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value real(kind=wp) public pure function mfi_sdot (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value real(kind=wp) public pure function mfi_ddot (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value real(kind=wp) public pure function mfi_cdotu (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public pure function mfi_zdotu (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public pure function mfi_cdotc (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public pure function mfi_zdotc (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy Return Value complex(kind=wp) public pure function mfi_isamax (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_idamax (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_icamax (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_izamax (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_isamin (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_idamin (x, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_icamin (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_izamin (x, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) integer, intent(in), optional :: incx Return Value integer public pure function mfi_slamch (cmach, kind) result(res) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach real(kind=wp), intent(in) :: kind Just a kind placeholder Return Value real(kind=wp) public pure function mfi_dlamch (cmach, kind) result(res) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach real(kind=wp), intent(in) :: kind Just a kind placeholder Return Value real(kind=wp) Subroutines public pure subroutine mfi_saxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_daxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_caxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zaxpy (x, y, a, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in), optional :: a integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_scopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dcopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_ccopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zcopy (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_srot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_drot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_crot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c complex(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_csrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zdrot (x, y, c, s, incx, incy) Given two vectors x and y,\n each vector element of these vectors is replaced as follows: Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: s integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_srotm (x, y, param, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: param (5) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_drotm (x, y, param, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: param (5) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_sscal (x, a, incx) MFI_SSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_dscal (x, a, incx) MFI_DSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_cscal (x, a, incx) MFI_CSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_zscal (x, a, incx) MFI_ZSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) complex(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_csscal (x, a, incx) MFI_CSSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_zdscal (x, a, incx) MFI_ZDSCAL scales a vector by a constant. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: x (:) real(kind=wp), intent(in) :: a integer, intent(in), optional :: incx public pure subroutine mfi_sswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zswap (x, y, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_sgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgbmv (a, x, y, kl, m, alpha, beta, trans, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) integer, intent(in), optional :: kl integer, intent(in), optional :: m complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta character(len=1), intent(in), optional :: trans integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_sgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgemv (a, x, y, trans, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_sger (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dger (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cgerc (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgerc (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cgeru (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zgeru (a, x, y, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_chbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_chemv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhemv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_cher (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_zher (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_cher2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zher2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_chpmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhpmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_chpr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_zhpr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_chpr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_zhpr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: ap (:) complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_ssbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsbmv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_sspmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dspmv (ap, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_sspr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_dspr (ap, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_sspr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dspr2 (ap, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ap (:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_ssymv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsymv (a, x, y, uplo, alpha, beta, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_ssyr (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_dsyr (a, x, uplo, alpha, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx public pure subroutine mfi_ssyr2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_dsyr2 (a, x, y, uplo, alpha, incx, incy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(in) :: y (:) character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha integer, intent(in), optional :: incx integer, intent(in), optional :: incy public pure subroutine mfi_stbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztbmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_stbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztbsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_stpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztpmv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_stpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ap (:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztpsv (ap, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: ap (:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_strmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztrmv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_strsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_dtrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ctrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_ztrsv (a, x, uplo, trans, diag, incx) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: x (:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans character(len=1), intent(in), optional :: diag integer, intent(in), optional :: incx public pure subroutine mfi_sgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_cgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zgemm (a, b, c, transa, transb, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public pure subroutine mfi_chemm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zhemm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo complex(kind=wp), intent(in), optional :: alpha complex(kind=wp), intent(in), optional :: beta public pure subroutine mfi_cherk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zherk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_cher2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_zher2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(in) :: b (:,:) complex(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans complex(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_ssymm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsymm (a, b, c, side, uplo, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_ssyrk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsyrk (a, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_ssyr2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_dsyr2k (a, b, c, uplo, trans, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(in) :: b (:,:) real(kind=wp), intent(inout) :: c (:,:) character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: trans real(kind=wp), intent(in), optional :: alpha real(kind=wp), intent(in), optional :: beta public pure subroutine mfi_strmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_dtrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ctrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ztrmm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_strsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_dtrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag real(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ctrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha public pure subroutine mfi_ztrsm (a, b, side, uplo, transa, diag, alpha) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: side character(len=1), intent(in), optional :: uplo character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: diag complex(kind=wp), intent(in), optional :: alpha","tags":"","loc":"module/mfi_blas.html"},{"title":"mfi_lapack – MFI - Modern Fortran Interfaces","text":"Modern fortran interfaces for LAPACK Uses f77_lapack iso_fortran_env Interfaces public        interface mfi_geqrf public pure subroutine mfi_sgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_dgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_cgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_zgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public        interface mfi_gerqf public pure subroutine mfi_sgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_dgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_cgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_zgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public        interface mfi_getrf public pure subroutine mfi_sgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_dgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_cgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public        interface mfi_getri public pure subroutine mfi_sgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_dgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_cgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public        interface mfi_getrs public pure subroutine mfi_sgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_dgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_cgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_zgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public        interface mfi_hetrf public pure subroutine mfi_chetrf (a, uplo, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zhetrf (a, uplo, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public        interface mfi_hegv public pure subroutine mfi_chegv (a, b, w, itype, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) real(kind=wp), intent(out) :: w (:) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zhegv (a, b, w, itype, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) real(kind=wp), intent(out) :: w (:) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public        interface mfi_heevd public pure subroutine mfi_cheevd (a, w, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: w (:) character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zheevd (a, w, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: w (:) character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public        interface mfi_gesvd public pure subroutine mfi_sgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) real(kind=wp), intent(out), optional, target :: u (:,:) real(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_dgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) real(kind=wp), intent(out), optional, target :: u (:,:) real(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_cgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) complex(kind=wp), intent(out), optional, target :: u (:,:) complex(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_zgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) complex(kind=wp), intent(out), optional, target :: u (:,:) complex(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public        interface mfi_potrf public pure subroutine mfi_spotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_dpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_cpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_zpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public        interface mfi_potri public pure subroutine mfi_spotri (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_dpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_cpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_zpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public        interface mfi_potrs public pure subroutine mfi_spotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_dpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_cpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public        interface mfi_pocon public pure subroutine mfi_spocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_dpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_cpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info Subroutines public pure subroutine mfi_sgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_dgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_cgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_zgeqrf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_sgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_dgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_cgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_zgerqf (a, tau, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(out), optional, target :: tau (:) integer, intent(out), optional :: info public pure subroutine mfi_sgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_dgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_cgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zgetrf (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_sgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_dgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_cgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zgetri (a, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_sgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_dgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_cgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_zgetrs (a, ipiv, b, trans, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(in) :: ipiv (:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: trans integer, intent(out), optional :: info public pure subroutine mfi_chetrf (a, uplo, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_zhetrf (a, uplo, ipiv, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional, target :: ipiv (:) integer, intent(out), optional :: info public pure subroutine mfi_chegv (a, b, w, itype, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) real(kind=wp), intent(out) :: w (:) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zhegv (a, b, w, itype, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) real(kind=wp), intent(out) :: w (:) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_cheevd (a, w, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: w (:) character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zheevd (a, w, jobz, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: w (:) character(len=1), intent(in), optional :: jobz character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_sgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) real(kind=wp), intent(out), optional, target :: u (:,:) real(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_dgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) real(kind=wp), intent(out), optional, target :: u (:,:) real(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_cgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) complex(kind=wp), intent(out), optional, target :: u (:,:) complex(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_zgesvd (a, s, u, vt, ww, job, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(out) :: s (:) complex(kind=wp), intent(out), optional, target :: u (:,:) complex(kind=wp), intent(out), optional, target :: vt (:,:) real(kind=wp), intent(out), optional, target :: ww (:) character(len=1), intent(in), optional :: job integer, intent(out), optional :: info public pure subroutine mfi_spotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_dpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_cpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_zpotrf (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_spotri (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_dpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_cpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_zpotri (a, info, uplo) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) integer, intent(out), optional :: info character(len=1), intent(in), optional :: uplo public pure subroutine mfi_spotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_dpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:,:) real(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_cpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zpotrs (a, b, uplo, info) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: a (:,:) complex(kind=wp), intent(inout) :: b (:,:) character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_spocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_dpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_cpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_zpocon (a, anorm, rcond, uplo, info) Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a (:,:) real(kind=wp), intent(in) :: anorm real(kind=wp), intent(out) :: rcond character(len=1), intent(in), optional :: uplo integer, intent(out), optional :: info public pure subroutine mfi_error (name, info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name integer, intent(in) :: info","tags":"","loc":"module/mfi_lapack.html"},{"title":"lapack.f90 – MFI - Modern Fortran Interfaces","text":"Source Code !> Improved and original F77 interfaces for LAPACK module f77_lapack use iso_fortran_env implicit none interface pure subroutine sgeqrf ( m , n , a , lda , tau , work , lwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: tau ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork real ( wp ), intent ( inout ) :: work ( * ) end subroutine pure subroutine dgeqrf ( m , n , a , lda , tau , work , lwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: tau ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork real ( wp ), intent ( inout ) :: work ( * ) end subroutine pure subroutine cgeqrf ( m , n , a , lda , tau , work , lwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( out ) :: tau ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork complex ( wp ), intent ( inout ) :: work ( * ) end subroutine pure subroutine zgeqrf ( m , n , a , lda , tau , work , lwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( out ) :: tau ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork complex ( wp ), intent ( inout ) :: work ( * ) end subroutine end interface interface f77_geqrf procedure :: sgeqrf procedure :: dgeqrf procedure :: cgeqrf procedure :: zgeqrf end interface interface pure subroutine sgerqf ( m , n , a , lda , tau , work , lwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: tau ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork real ( wp ), intent ( inout ) :: work ( * ) end subroutine pure subroutine dgerqf ( m , n , a , lda , tau , work , lwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: tau ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork real ( wp ), intent ( inout ) :: work ( * ) end subroutine pure subroutine cgerqf ( m , n , a , lda , tau , work , lwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( out ) :: tau ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork complex ( wp ), intent ( inout ) :: work ( * ) end subroutine pure subroutine zgerqf ( m , n , a , lda , tau , work , lwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( out ) :: tau ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork complex ( wp ), intent ( inout ) :: work ( * ) end subroutine end interface interface f77_gerqf procedure :: sgerqf procedure :: dgerqf procedure :: cgerqf procedure :: zgerqf end interface interface pure subroutine sgetrf ( m , n , a , lda , ipiv , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a ( lda , * ) integer , intent ( out ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda end subroutine pure subroutine dgetrf ( m , n , a , lda , ipiv , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a ( lda , * ) integer , intent ( out ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda end subroutine pure subroutine cgetrf ( m , n , a , lda , ipiv , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) integer , intent ( out ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda end subroutine pure subroutine zgetrf ( m , n , a , lda , ipiv , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) integer , intent ( out ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda end subroutine end interface interface f77_getrf procedure :: sgetrf procedure :: dgetrf procedure :: cgetrf procedure :: zgetrf end interface interface pure subroutine sgetri ( n , a , lda , ipiv , work , lwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: work ( * ) integer , intent ( in ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork end subroutine pure subroutine dgetri ( n , a , lda , ipiv , work , lwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: work ( * ) integer , intent ( in ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork end subroutine pure subroutine cgetri ( n , a , lda , ipiv , work , lwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: work ( * ) integer , intent ( in ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork end subroutine pure subroutine zgetri ( n , a , lda , ipiv , work , lwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: work ( * ) integer , intent ( in ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork end subroutine end interface interface f77_getri procedure :: sgetri procedure :: dgetri procedure :: cgetri procedure :: zgetri end interface interface pure subroutine sgetrs ( trans , n , nrhs , a , lda , ipiv , b , ldb , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: trans integer , intent ( in ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: nrhs integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine dgetrs ( trans , n , nrhs , a , lda , ipiv , b , ldb , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: trans integer , intent ( in ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: nrhs integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine cgetrs ( trans , n , nrhs , a , lda , ipiv , b , ldb , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: trans integer , intent ( in ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: nrhs integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine zgetrs ( trans , n , nrhs , a , lda , ipiv , b , ldb , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: trans integer , intent ( in ) :: ipiv ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: nrhs integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine end interface interface f77_getrs procedure :: sgetrs procedure :: dgetrs procedure :: cgetrs procedure :: zgetrs end interface interface pure subroutine chetrf ( uplo , n , a , lda , ipiv , work , lwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: ipiv ( * ) complex ( wp ), intent ( inout ) :: work ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork end subroutine pure subroutine zhetrf ( uplo , n , a , lda , ipiv , work , lwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: ipiv ( * ) complex ( wp ), intent ( inout ) :: work ( * ) integer , intent ( out ) :: info integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork end subroutine end interface interface f77_hetrf procedure :: chetrf procedure :: zhetrf end interface interface pure subroutine chegv ( itype , jobz , uplo , n , a , lda , b , ldb , w , work , lwork , rwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: b ( ldb , * ) real ( wp ), intent ( out ) :: w ( * ) integer , intent ( out ) :: info character , intent ( in ) :: jobz character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: itype integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: lwork complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( in ) :: rwork ( * ) end subroutine pure subroutine zhegv ( itype , jobz , uplo , n , a , lda , b , ldb , w , work , lwork , rwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: b ( ldb , * ) real ( wp ), intent ( out ) :: w ( * ) integer , intent ( out ) :: info character , intent ( in ) :: jobz character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: itype integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: lwork complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( in ) :: rwork ( * ) end subroutine end interface interface f77_hegv procedure :: chegv procedure :: zhegv end interface interface pure subroutine cheevd ( jobz , uplo , n , a , lda , w , work , lwork , rwork , lrwork , iwork , liwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: w ( * ) integer , intent ( out ) :: info character , intent ( in ) :: jobz character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork integer , intent ( in ) :: lrwork integer , intent ( in ) :: liwork complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( inout ) :: rwork ( * ) integer , intent ( inout ) :: iwork ( * ) end subroutine pure subroutine zheevd ( jobz , uplo , n , a , lda , w , work , lwork , rwork , lrwork , iwork , liwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: w ( * ) integer , intent ( out ) :: info character , intent ( in ) :: jobz character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: lwork integer , intent ( in ) :: lrwork integer , intent ( in ) :: liwork complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( inout ) :: rwork ( * ) integer , intent ( inout ) :: iwork ( * ) end subroutine end interface interface f77_heevd procedure :: cheevd procedure :: zheevd end interface interface pure subroutine cheevx ( jobz , range , uplo , n , a , lda , vl , vu , il , iu , abstol , m , w , z , ldz ,& work , lwork , rwork , lrwork , iwork , liwork , ifail , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: z ( ldz , * ) real ( wp ), intent ( out ) :: w ( * ) integer , intent ( out ) :: info character , intent ( in ) :: jobz character , intent ( in ) :: uplo character , intent ( in ) :: range real ( wp ), intent ( in ) :: vl real ( wp ), intent ( in ) :: vu real ( wp ), intent ( in ) :: abstol integer , intent ( in ) :: n integer , intent ( in ) :: m integer , intent ( in ) :: lda integer , intent ( in ) :: ldz integer , intent ( in ) :: il integer , intent ( in ) :: iu integer , intent ( in ) :: lwork integer , intent ( in ) :: lrwork integer , intent ( in ) :: liwork integer , intent ( in ) :: ifail complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( inout ) :: rwork ( * ) integer , intent ( inout ) :: iwork ( * ) end subroutine pure subroutine zheevx ( jobz , range , uplo , n , a , lda , vl , vu , il , iu , abstol , m , w , z , ldz ,& work , lwork , rwork , lrwork , iwork , liwork , ifail , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: z ( ldz , * ) real ( wp ), intent ( out ) :: w ( * ) integer , intent ( out ) :: info character , intent ( in ) :: jobz character , intent ( in ) :: uplo character , intent ( in ) :: range real ( wp ), intent ( in ) :: vl real ( wp ), intent ( in ) :: vu real ( wp ), intent ( in ) :: abstol integer , intent ( in ) :: n integer , intent ( in ) :: m integer , intent ( in ) :: lda integer , intent ( in ) :: ldz integer , intent ( in ) :: il integer , intent ( in ) :: iu integer , intent ( in ) :: lwork integer , intent ( in ) :: lrwork integer , intent ( in ) :: liwork integer , intent ( in ) :: ifail complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( inout ) :: rwork ( * ) integer , intent ( inout ) :: iwork ( * ) end subroutine end interface interface f77_heevx procedure :: cheevx procedure :: zheevx end interface interface pure subroutine cheevr ( jobz , range , uplo , n , a , lda , vl , vu , il , iu , abstol , m , w , z , ldz ,& isuppz , work , lwork , rwork , lrwork , iwork , liwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: z ( ldz , * ) real ( wp ), intent ( out ) :: w ( * ) integer , intent ( out ) :: info character , intent ( in ) :: jobz character , intent ( in ) :: uplo character , intent ( in ) :: range real ( wp ), intent ( in ) :: vl real ( wp ), intent ( in ) :: vu real ( wp ), intent ( in ) :: abstol integer , intent ( in ) :: n integer , intent ( in ) :: m integer , intent ( in ) :: lda integer , intent ( in ) :: ldz integer , intent ( in ) :: il integer , intent ( in ) :: iu integer , intent ( in ) :: lwork integer , intent ( in ) :: lrwork integer , intent ( in ) :: liwork integer , intent ( in ) :: isuppz ( * ) complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( inout ) :: rwork ( * ) integer , intent ( inout ) :: iwork ( * ) end subroutine pure subroutine zheevr ( jobz , range , uplo , n , a , lda , vl , vu , il , iu , abstol , m , w , z , ldz ,& isuppz , work , lwork , rwork , lrwork , iwork , liwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: z ( ldz , * ) real ( wp ), intent ( out ) :: w ( * ) integer , intent ( out ) :: info character , intent ( in ) :: jobz character , intent ( in ) :: uplo character , intent ( in ) :: range real ( wp ), intent ( in ) :: vl real ( wp ), intent ( in ) :: vu real ( wp ), intent ( in ) :: abstol integer , intent ( in ) :: n integer , intent ( in ) :: m integer , intent ( in ) :: lda integer , intent ( in ) :: ldz integer , intent ( in ) :: il integer , intent ( in ) :: iu integer , intent ( in ) :: lwork integer , intent ( in ) :: lrwork integer , intent ( in ) :: liwork integer , intent ( in ) :: isuppz ( * ) complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( inout ) :: rwork ( * ) integer , intent ( inout ) :: iwork ( * ) end subroutine end interface interface f77_heevr procedure :: cheevr procedure :: zheevr end interface interface pure subroutine sgesvd ( jobu , jobvt , m , n , a , lda , s , u , ldu , vt , ldvt , work , lwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: s ( * ) real ( wp ), intent ( out ) :: u ( ldu , * ) real ( wp ), intent ( out ) :: vt ( ldvt , * ) integer , intent ( out ) :: info character , intent ( in ) :: jobu character , intent ( in ) :: jobvt integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldu integer , intent ( in ) :: ldvt integer , intent ( in ) :: lwork real ( wp ), intent ( inout ) :: work ( * ) end subroutine pure subroutine dgesvd ( jobu , jobvt , m , n , a , lda , s , u , ldu , vt , ldvt , work , lwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: s ( * ) real ( wp ), intent ( out ) :: u ( ldu , * ) real ( wp ), intent ( out ) :: vt ( ldvt , * ) integer , intent ( out ) :: info character , intent ( in ) :: jobu character , intent ( in ) :: jobvt integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldu integer , intent ( in ) :: ldvt integer , intent ( in ) :: lwork real ( wp ), intent ( inout ) :: work ( * ) end subroutine pure subroutine cgesvd ( jobu , jobvt , m , n , a , lda , s , u , ldu , vt , ldvt , work , lwork , rwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: s ( * ) complex ( wp ), intent ( out ) :: u ( ldu , * ) complex ( wp ), intent ( out ) :: vt ( ldvt , * ) integer , intent ( out ) :: info character , intent ( in ) :: jobu character , intent ( in ) :: jobvt integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldu integer , intent ( in ) :: ldvt integer , intent ( in ) :: lwork complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( in ) :: rwork ( * ) end subroutine pure subroutine zgesvd ( jobu , jobvt , m , n , a , lda , s , u , ldu , vt , ldvt , work , lwork , rwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( out ) :: s ( * ) complex ( wp ), intent ( out ) :: u ( ldu , * ) complex ( wp ), intent ( out ) :: vt ( ldvt , * ) integer , intent ( out ) :: info character , intent ( in ) :: jobu character , intent ( in ) :: jobvt integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldu integer , intent ( in ) :: ldvt integer , intent ( in ) :: lwork complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( in ) :: rwork ( * ) end subroutine end interface interface f77_gesvd procedure :: sgesvd procedure :: dgesvd procedure :: cgesvd procedure :: zgesvd end interface interface pure subroutine spotrf ( uplo , n , a , lda , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( out ) :: info end subroutine pure subroutine dpotrf ( uplo , n , a , lda , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( out ) :: info end subroutine pure subroutine cpotrf ( uplo , n , a , lda , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( out ) :: info end subroutine pure subroutine zpotrf ( uplo , n , a , lda , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( out ) :: info end subroutine end interface interface f77_potrf procedure :: spotrf procedure :: dpotrf procedure :: cpotrf procedure :: zpotrf end interface interface pure subroutine spotri ( uplo , n , a , lda , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( out ) :: info end subroutine pure subroutine dpotri ( uplo , n , a , lda , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( out ) :: info end subroutine pure subroutine cpotri ( uplo , n , a , lda , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( out ) :: info end subroutine pure subroutine zpotri ( uplo , n , a , lda , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( out ) :: info end subroutine end interface interface f77_potri procedure :: spotri procedure :: dpotri procedure :: cpotri procedure :: zpotri end interface interface pure subroutine spotrs ( uplo , n , nrhs , a , lda , b , ldb , info ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: b ( ldb , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: nrhs integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( out ) :: info end subroutine pure subroutine dpotrs ( uplo , n , nrhs , a , lda , b , ldb , info ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: b ( ldb , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: nrhs integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( out ) :: info end subroutine pure subroutine cpotrs ( uplo , n , nrhs , a , lda , b , ldb , info ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: b ( ldb , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: nrhs integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( out ) :: info end subroutine pure subroutine zpotrs ( uplo , n , nrhs , a , lda , b , ldb , info ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: b ( ldb , * ) character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: nrhs integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( out ) :: info end subroutine end interface interface f77_potrs procedure :: spotrs procedure :: dpotrs procedure :: cpotrs procedure :: zpotrs end interface interface !> spocon estimates the reciprocal of the condition number (in the !> 1-norm) of a real(REAL32) Hermitian positive definite matrix using the !> Cholesky factorization A = U**H*U or A = L*L**H computed by sPOTRF. !> An estimate is obtained for norm(inv(A)), and the reciprocal of the !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))). pure subroutine spocon ( uplo , n , a , lda , anorm , rcond , work , iwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( in ) :: anorm real ( wp ), intent ( out ) :: rcond real ( wp ), intent ( inout ) :: work ( * ) integer , intent ( inout ) :: iwork ( * ) integer , intent ( out ) :: info end subroutine !> dpocon estimates the reciprocal of the condition number (in the !> 1-norm) of a real(REAL64) Hermitian positive definite matrix using the !> Cholesky factorization A = U**H*U or A = L*L**H computed by dPOTRF. !> An estimate is obtained for norm(inv(A)), and the reciprocal of the !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))). pure subroutine dpocon ( uplo , n , a , lda , anorm , rcond , work , iwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( in ) :: anorm real ( wp ), intent ( out ) :: rcond real ( wp ), intent ( inout ) :: work ( * ) integer , intent ( inout ) :: iwork ( * ) integer , intent ( out ) :: info end subroutine !> cpocon estimates the reciprocal of the condition number (in the !> 1-norm) of a complex(REAL32) Hermitian positive definite matrix using the !> Cholesky factorization A = U**H*U or A = L*L**H computed by cPOTRF. !> An estimate is obtained for norm(inv(A)), and the reciprocal of the !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))). pure subroutine cpocon ( uplo , n , a , lda , anorm , rcond , work , rwork , info ) import :: REAL32 integer , parameter :: wp = REAL32 character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda complex ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( in ) :: anorm real ( wp ), intent ( out ) :: rcond complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( inout ) :: rwork ( * ) integer , intent ( out ) :: info end subroutine !> zpocon estimates the reciprocal of the condition number (in the !> 1-norm) of a complex(REAL64) Hermitian positive definite matrix using the !> Cholesky factorization A = U**H*U or A = L*L**H computed by zPOTRF. !> An estimate is obtained for norm(inv(A)), and the reciprocal of the !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))). pure subroutine zpocon ( uplo , n , a , lda , anorm , rcond , work , rwork , info ) import :: REAL64 integer , parameter :: wp = REAL64 character , intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda complex ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( in ) :: anorm real ( wp ), intent ( out ) :: rcond complex ( wp ), intent ( inout ) :: work ( * ) real ( wp ), intent ( inout ) :: rwork ( * ) integer , intent ( out ) :: info end subroutine end interface interface f77_pocon procedure :: spocon procedure :: dpocon procedure :: cpocon procedure :: zpocon end interface ! Other Auxiliary Routines interface pure subroutine slartg ( f , g , c , s , r ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: c real ( wp ), intent ( inout ) :: f real ( wp ), intent ( inout ) :: g real ( wp ), intent ( inout ) :: r real ( wp ), intent ( inout ) :: s end subroutine pure subroutine dlartg ( f , g , c , s , r ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: c real ( wp ), intent ( inout ) :: f real ( wp ), intent ( inout ) :: g real ( wp ), intent ( inout ) :: r real ( wp ), intent ( inout ) :: s end subroutine pure subroutine clartg ( f , g , c , s , r ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: c complex ( wp ), intent ( inout ) :: f complex ( wp ), intent ( inout ) :: g complex ( wp ), intent ( inout ) :: r complex ( wp ), intent ( inout ) :: s end subroutine pure subroutine zlartg ( f , g , c , s , r ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: c complex ( wp ), intent ( inout ) :: f complex ( wp ), intent ( inout ) :: g complex ( wp ), intent ( inout ) :: r complex ( wp ), intent ( inout ) :: s end subroutine end interface interface f77_lartg procedure :: slartg procedure :: dlartg procedure :: clartg procedure :: zlartg end interface interface f77_xerbla pure subroutine xerbla ( name , info ) character ( * ), intent ( in ) :: name integer , intent ( in ) :: info end subroutine end interface f77_xerbla end module","tags":"","loc":"sourcefile/lapack.f90.html"},{"title":"blas.f90 – MFI - Modern Fortran Interfaces","text":"Source Code !> Improved and original F77 interfaces for blas module f77_blas use iso_fortran_env implicit none !FIXME rot, dot, rotg, nrm2: problem with functions that have TYPE /= TYPE_result ! BLAS level 1 interface pure subroutine saxpy ( n , a , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: a real ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine daxpy ( n , a , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: a real ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine caxpy ( n , a , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: a complex ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zaxpy ( n , a , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: a complex ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_axpy procedure :: saxpy procedure :: daxpy procedure :: caxpy procedure :: zaxpy end interface interface pure subroutine scopy ( n , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dcopy ( n , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine ccopy ( n , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zcopy ( n , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_copy procedure :: scopy procedure :: dcopy procedure :: ccopy procedure :: zcopy end interface interface pure function sdot ( n , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ) :: sdot real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end function pure function ddot ( n , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ) :: ddot real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end function end interface interface f77_dot procedure :: sdot procedure :: ddot end interface interface pure function cdotu ( n , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ) :: cdotu complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end function pure function zdotu ( n , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ) :: zdotu complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end function end interface interface f77_dotu procedure :: cdotu procedure :: zdotu end interface interface pure function cdotc ( n , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ) :: cdotc complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end function pure function zdotc ( n , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ) :: zdotc complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end function end interface interface f77_dotc procedure :: cdotc procedure :: zdotc end interface interface !>srotg generates a Givens rotation with real cosine and complex sine: !>``` !> [  c  s ] [ a ] = [ r ] !> [ -s  c ] [ b ]   [ 0 ] !>``` !> satisfying `c**2 + s**2 = 1`. pure subroutine srotg ( a , b , c , s ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a real ( wp ), intent ( inout ) :: b real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s end subroutine !>drotg generates a Givens rotation with real cosine and complex sine: !>``` !> [  c  s ] [ a ] = [ r ] !> [ -s  c ] [ b ]   [ 0 ] !>``` !> satisfying `c**2 + s**2 = 1`. pure subroutine drotg ( a , b , c , s ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a real ( wp ), intent ( inout ) :: b real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s end subroutine !>crotg generates a Givens rotation with real cosine and complex sine: !>``` !>  [  c         s ] [ a ] = [ r ] !>  [ -conjg(s)  c ] [ b ]   [ 0 ] !>``` !> where c is real, s is complex, and `c**2 + conjg(s)*s = 1`. pure subroutine crotg ( a , b , c , s ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a complex ( wp ), intent ( inout ) :: b real ( wp ), intent ( out ) :: c complex ( wp ), intent ( out ) :: s end subroutine !>zrotg generates a Givens rotation with real cosine and complex sine: !>``` !>  [  c         s ] [ a ] = [ r ] !>  [ -conjg(s)  c ] [ b ]   [ 0 ] !>``` !> where c is real, s is complex, and `c**2 + conjg(s)*s = 1`. pure subroutine zrotg ( a , b , c , s ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a complex ( wp ), intent ( inout ) :: b real ( wp ), intent ( out ) :: c complex ( wp ), intent ( out ) :: s end subroutine end interface interface f77_rotg procedure :: srotg procedure :: drotg procedure :: crotg procedure :: zrotg end interface interface pure subroutine srotm ( n , x , incx , y , incy , param ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) real ( wp ), intent ( in ) :: param ( 5 ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine drotm ( n , x , incx , y , incy , param ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) real ( wp ), intent ( in ) :: param ( 5 ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_rotm procedure :: srotm procedure :: drotm end interface interface pure subroutine srotmg ( d1 , d2 , x1 , y1 , param ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: y1 real ( wp ), intent ( out ) :: param ( 5 ) real ( wp ), intent ( inout ) :: d1 real ( wp ), intent ( inout ) :: d2 real ( wp ), intent ( inout ) :: x1 end subroutine pure subroutine drotmg ( d1 , d2 , x1 , y1 , param ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: y1 real ( wp ), intent ( out ) :: param ( 5 ) real ( wp ), intent ( inout ) :: d1 real ( wp ), intent ( inout ) :: d2 real ( wp ), intent ( inout ) :: x1 end subroutine end interface interface f77_rotmg procedure :: srotmg procedure :: drotmg end interface interface pure subroutine sswap ( n , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dswap ( n , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine cswap ( n , x , incx , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zswap ( n , x , incx , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_swap procedure :: sswap procedure :: dswap procedure :: cswap procedure :: zswap end interface interface pure function sasum ( n , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ) :: sasum real ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx end function pure function dasum ( n , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ) :: dasum real ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx end function pure function scasum ( n , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ) :: scasum complex ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx end function pure function dzasum ( n , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ) :: dzasum complex ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx end function end interface interface f77_asum procedure :: sasum procedure :: dasum procedure :: scasum procedure :: dzasum end interface interface pure function snrm2 ( n , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ) :: snrm2 real ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx end function pure function dnrm2 ( n , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ) :: dnrm2 real ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx end function pure function scnrm2 ( n , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ) :: scnrm2 complex ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx end function pure function dznrm2 ( n , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ) :: dznrm2 complex ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx end function end interface interface f77_nrm2 procedure :: snrm2 procedure :: dnrm2 procedure :: scnrm2 procedure :: dznrm2 end interface interface !> SSCAL scales a vector by a constant. pure subroutine sscal ( n , a , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: x ( * ) real ( wp ), intent ( in ) :: a integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine !> DSCAL scales a vector by a constant. pure subroutine dscal ( n , a , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: x ( * ) real ( wp ), intent ( in ) :: a integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine !> CSCAL scales a vector by a constant. pure subroutine cscal ( n , a , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: x ( * ) complex ( wp ), intent ( in ) :: a integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine !> ZSCAL scales a vector by a constant. pure subroutine zscal ( n , a , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: x ( * ) complex ( wp ), intent ( in ) :: a integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine end interface interface !> CSSCAL scales a vector by a constant. pure subroutine csscal ( n , a , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: x ( * ) real ( wp ), intent ( in ) :: a integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine !> ZDSCAL scales a vector by a constant. pure subroutine zdscal ( n , a , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: x ( * ) real ( wp ), intent ( in ) :: a integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine end interface interface f77_scal procedure :: sscal procedure :: dscal procedure :: cscal procedure :: zscal procedure :: csscal procedure :: zdscal end interface interface !> SROT applies a plane rotation. pure subroutine srot ( n , x , incx , y , incy , c , s ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy real ( wp ), intent ( in ) :: c real ( wp ), intent ( in ) :: s end subroutine !> DROT applies a plane rotation. pure subroutine drot ( n , x , incx , y , incy , c , s ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy real ( wp ), intent ( in ) :: c real ( wp ), intent ( in ) :: s end subroutine !> CROT applies a plane rotation. pure subroutine crot ( n , x , incx , y , incy , c , s ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy real ( wp ), intent ( in ) :: c complex ( wp ), intent ( in ) :: s end subroutine !> ZROT applies a plane rotation. pure subroutine zrot ( n , x , incx , y , incy , c , s ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy real ( wp ), intent ( in ) :: c complex ( wp ), intent ( in ) :: s end subroutine end interface interface !> CSROT applies a plane rotation, !> where the cos and sin (c and s) are real !> and the vectors x and y are complex. pure subroutine csrot ( n , x , incx , y , incy , c , s ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy real ( wp ), intent ( in ) :: c real ( wp ), intent ( in ) :: s end subroutine !> ZDROT applies a plane rotation, !> where the cos and sin (c and s) are real !> and the vectors x and y are complex. pure subroutine zdrot ( n , x , incx , y , incy , c , s ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy real ( wp ), intent ( in ) :: c real ( wp ), intent ( in ) :: s end subroutine end interface interface f77_rot procedure :: srot procedure :: drot procedure :: crot procedure :: zrot procedure :: csrot procedure :: zdrot end interface ! BLAS level 2 interface pure subroutine sgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: trans real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: kl integer , intent ( in ) :: ku integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: trans real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: kl integer , intent ( in ) :: ku integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine cgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: trans complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: kl integer , intent ( in ) :: ku integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: trans complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: kl integer , intent ( in ) :: ku integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_gbmv procedure :: sgbmv procedure :: dgbmv procedure :: cgbmv procedure :: zgbmv end interface interface pure subroutine sgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: trans real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: trans real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine cgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: trans complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: trans complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_gemv procedure :: sgemv procedure :: dgemv procedure :: cgemv procedure :: zgemv end interface interface pure subroutine sger ( m , n , alpha , x , incx , y , incy , a , lda ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dger ( m , n , alpha , x , incx , y , incy , a , lda ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) real ( wp ), intent ( inout ) :: a ( lda , * ) real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_ger procedure :: sger procedure :: dger end interface interface pure subroutine cgerc ( m , n , alpha , x , incx , y , incy , a , lda ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zgerc ( m , n , alpha , x , incx , y , incy , a , lda ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_gerc procedure :: cgerc procedure :: zgerc end interface interface pure subroutine cgeru ( m , n , alpha , x , incx , y , incy , a , lda ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zgeru ( m , n , alpha , x , incx , y , incy , a , lda ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) complex ( wp ), intent ( inout ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_geru procedure :: cgeru procedure :: zgeru end interface interface pure subroutine chbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zhbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_hbmv procedure :: chbmv procedure :: zhbmv end interface interface pure subroutine chemv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zhemv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_hemv procedure :: chemv procedure :: zhemv end interface interface pure subroutine cher ( uplo , n , alpha , x , incx , a , lda ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine zher ( uplo , n , alpha , x , incx , a , lda ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine end interface interface f77_her procedure :: cher procedure :: zher end interface interface pure subroutine cher2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) complex ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zher2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) complex ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_her2 procedure :: cher2 procedure :: zher2 end interface interface pure subroutine chpmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: ap ( * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zhpmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: ap ( * ) complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_hpmv procedure :: chpmv procedure :: zhpmv end interface interface pure subroutine chpr ( uplo , n , alpha , x , incx , ap ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: ap ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine pure subroutine zhpr ( uplo , n , alpha , x , incx , ap ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( inout ) :: ap ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine end interface interface f77_hpr procedure :: chpr procedure :: zhpr end interface interface pure subroutine chpr2 ( uplo , n , alpha , x , incx , y , incy , ap ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) complex ( wp ), intent ( inout ) :: ap ( * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine zhpr2 ( uplo , n , alpha , x , incx , y , incy , ap ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x ( * ) complex ( wp ), intent ( in ) :: y ( * ) complex ( wp ), intent ( inout ) :: ap ( * ) character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_hpr2 procedure :: chpr2 procedure :: zhpr2 end interface interface pure subroutine ssbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dsbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_sbmv procedure :: ssbmv procedure :: dsbmv end interface interface pure subroutine sspmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: ap ( * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dspmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: ap ( * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_spmv procedure :: sspmv procedure :: dspmv end interface interface pure subroutine sspr ( uplo , n , alpha , x , incx , ap ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: ap ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine pure subroutine dspr ( uplo , n , alpha , x , incx , ap ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: ap ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine end interface interface f77_spr procedure :: sspr procedure :: dspr end interface interface pure subroutine sspr2 ( uplo , n , alpha , x , incx , y , incy , ap ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) real ( wp ), intent ( inout ) :: ap ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dspr2 ( uplo , n , alpha , x , incx , y , incy , ap ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) real ( wp ), intent ( inout ) :: ap ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_spr2 procedure :: sspr2 procedure :: dspr2 end interface interface pure subroutine ssymv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dsymv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: y ( * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_symv procedure :: ssymv procedure :: dsymv end interface interface pure subroutine ssyr ( uplo , n , alpha , x , incx , a , lda ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine dsyr ( uplo , n , alpha , x , incx , a , lda ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine end interface interface f77_syr procedure :: ssyr procedure :: dsyr end interface interface pure subroutine ssyr2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) real ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine pure subroutine dsyr2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x ( * ) real ( wp ), intent ( in ) :: y ( * ) real ( wp ), intent ( inout ) :: a ( lda , * ) character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx integer , intent ( in ) :: incy end subroutine end interface interface f77_syr2 procedure :: ssyr2 procedure :: dsyr2 end interface interface pure subroutine stbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine dtbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine ctbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine ztbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine end interface interface f77_tbmv procedure :: stbmv procedure :: dtbmv procedure :: ctbmv procedure :: ztbmv end interface interface pure subroutine stbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine dtbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine ctbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine ztbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine end interface interface f77_tbsv procedure :: stbsv procedure :: dtbsv procedure :: ctbsv procedure :: ztbsv end interface interface pure subroutine stpmv ( uplo , trans , diag , n , ap , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: ap ( * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine pure subroutine dtpmv ( uplo , trans , diag , n , ap , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: ap ( * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine pure subroutine ctpmv ( uplo , trans , diag , n , ap , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: ap ( * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine pure subroutine ztpmv ( uplo , trans , diag , n , ap , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: ap ( * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine end interface interface f77_tpmv procedure :: stpmv procedure :: dtpmv procedure :: ctpmv procedure :: ztpmv end interface interface pure subroutine stpsv ( uplo , trans , diag , n , ap , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: ap ( * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine pure subroutine dtpsv ( uplo , trans , diag , n , ap , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: ap ( * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine pure subroutine ctpsv ( uplo , trans , diag , n , ap , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: ap ( * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine pure subroutine ztpsv ( uplo , trans , diag , n , ap , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: ap ( * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: incx end subroutine end interface interface f77_tpsv procedure :: stpsv procedure :: dtpsv procedure :: ctpsv procedure :: ztpsv end interface interface pure subroutine strmv ( uplo , trans , diag , n , a , lda , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine dtrmv ( uplo , trans , diag , n , a , lda , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine ctrmv ( uplo , trans , diag , n , a , lda , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine ztrmv ( uplo , trans , diag , n , a , lda , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine end interface interface f77_trmv procedure :: strmv procedure :: dtrmv procedure :: ctrmv procedure :: ztrmv end interface interface pure subroutine strsv ( uplo , trans , diag , n , a , lda , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine dtrsv ( uplo , trans , diag , n , a , lda , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine ctrsv ( uplo , trans , diag , n , a , lda , x , incx ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine pure subroutine ztrsv ( uplo , trans , diag , n , a , lda , x , incx ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: x ( * ) character , intent ( in ) :: uplo character , intent ( in ) :: trans character , intent ( in ) :: diag integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: incx end subroutine end interface interface f77_trsv procedure :: strsv procedure :: dtrsv procedure :: ctrsv procedure :: ztrsv end interface ! BLAS level 3 interface pure subroutine sgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: b ( ldb , * ) real ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: transa character , intent ( in ) :: transb real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine pure subroutine dgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: b ( ldb , * ) real ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: transa character , intent ( in ) :: transb real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine pure subroutine cgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: b ( ldb , * ) complex ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: transa character , intent ( in ) :: transb complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine pure subroutine zgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: b ( ldb , * ) complex ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: transa character , intent ( in ) :: transb complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine end interface interface f77_gemm procedure :: sgemm procedure :: dgemm procedure :: cgemm procedure :: zgemm end interface interface pure subroutine chemm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: b ( ldb , * ) complex ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine pure subroutine zhemm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: b ( ldb , * ) complex ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha complex ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine end interface interface f77_hemm procedure :: chemm procedure :: zhemm end interface interface pure subroutine cherk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: trans character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldc end subroutine pure subroutine zherk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: trans character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldc end subroutine end interface interface f77_herk procedure :: cherk procedure :: zherk end interface interface pure subroutine cher2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: b ( ldb , * ) complex ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: trans character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine pure subroutine zher2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( in ) :: b ( ldb , * ) complex ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: trans character , intent ( in ) :: uplo complex ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine end interface interface f77_her2k procedure :: cher2k procedure :: zher2k end interface interface pure subroutine ssymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: b ( ldb , * ) real ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine pure subroutine dsymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: b ( ldb , * ) real ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine end interface interface f77_symm procedure :: ssymm procedure :: dsymm end interface interface pure subroutine ssyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: trans character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldc end subroutine pure subroutine dsyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: trans character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldc end subroutine end interface interface f77_syrk procedure :: ssyrk procedure :: dsyrk end interface interface pure subroutine ssyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: b ( ldb , * ) real ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: trans character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine pure subroutine dsyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( in ) :: b ( ldb , * ) real ( wp ), intent ( inout ) :: c ( ldc , * ) character , intent ( in ) :: trans character , intent ( in ) :: uplo real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: beta integer , intent ( in ) :: n integer , intent ( in ) :: k integer , intent ( in ) :: lda integer , intent ( in ) :: ldb integer , intent ( in ) :: ldc end subroutine end interface interface f77_syr2k procedure :: ssyr2k procedure :: dsyr2k end interface interface pure subroutine strmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo character , intent ( in ) :: transa character , intent ( in ) :: diag real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine dtrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo character , intent ( in ) :: transa character , intent ( in ) :: diag real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine ctrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo character , intent ( in ) :: transa character , intent ( in ) :: diag complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine ztrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo character , intent ( in ) :: transa character , intent ( in ) :: diag complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine end interface interface f77_trmm procedure :: strmm procedure :: dtrmm procedure :: ctrmm procedure :: ztrmm end interface interface pure subroutine strsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo character , intent ( in ) :: transa character , intent ( in ) :: diag real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine dtrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) import :: REAL64 integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a ( lda , * ) real ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo character , intent ( in ) :: transa character , intent ( in ) :: diag real ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine ctrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) import :: REAL32 integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo character , intent ( in ) :: transa character , intent ( in ) :: diag complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine pure subroutine ztrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) import :: REAL64 integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a ( lda , * ) complex ( wp ), intent ( inout ) :: b ( ldb , * ) character , intent ( in ) :: side character , intent ( in ) :: uplo character , intent ( in ) :: transa character , intent ( in ) :: diag complex ( wp ), intent ( in ) :: alpha integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: lda integer , intent ( in ) :: ldb end subroutine end interface interface f77_trsm procedure :: strsm procedure :: dtrsm procedure :: ctrsm procedure :: ztrsm end interface interface !> SLAMCH determines single precision machine parameters. pure real ( REAL32 ) function slamch ( cmach ) import :: REAL32 character , intent ( in ) :: cmach end function !> DLAMCH determines double precision machine parameters. pure real ( REAL64 ) function dlamch ( cmach ) import :: REAL64 character , intent ( in ) :: cmach end function !> Compute the inner product of two vectors with extended !> precision accumulation. !> !> Returns S.P. result with dot product accumulated in D.P. !> SDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I*INCX)*SY(LY+I*INCY), !> where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is !> defined in a similar way using INCY. pure function sdsdot ( n , sb , sx , incx , sy , incy ) import :: REAL32 integer , parameter :: wp = REAL32 real ( wp ) :: sdsdot real ( wp ), intent ( in ) :: sx ( * ) real ( wp ), intent ( in ) :: sy ( * ) real ( wp ), intent ( in ) :: sb integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end function !> Compute the inner product of two vectors with extended !> precision accumulation and result. !> !> Returns D.P. dot product accumulated in D.P., for S.P. SX and SY !> DSDOT = sum for I = 0 to N-1 of  SX(LX+I*INCX) * SY(LY+I*INCY), !> where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is !> defined in a similar way using INCY. pure function dsdot ( n , sx , incx , sy , incy ) import :: REAL32 , REAL64 integer , parameter :: sp = REAL32 integer , parameter :: dp = REAL64 real ( dp ) :: dsdot real ( sp ), intent ( in ) :: sx ( * ) real ( sp ), intent ( in ) :: sy ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx integer , intent ( in ) :: incy end function end interface ! Extensions ! BLAS Level 1 - Utils / Extensions ! Implement the blas extensions in interface f77_iamax procedure :: isamax procedure :: idamax procedure :: icamax procedure :: izamax end interface interface f77_iamin procedure :: isamin procedure :: idamin procedure :: icamin procedure :: izamin end interface contains pure function isamax ( n , x , incx ) integer , parameter :: wp = REAL32 integer :: isamax real ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx !If either n or incx are not positive, the routine returns 0. if ( n <= 0 . or . incx <= 0 ) then isamax = 0 return end if isamax = minloc ( x ( 1 : n : incx ), dim = 1 ) end function pure function idamax ( n , x , incx ) integer , parameter :: wp = REAL64 integer :: idamax real ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx !If either n or incx are not positive, the routine returns 0. if ( n <= 0 . or . incx <= 0 ) then idamax = 0 return end if idamax = minloc ( x ( 1 : n : incx ), dim = 1 ) end function pure function icamax ( n , x , incx ) integer , parameter :: wp = REAL32 integer :: icamax complex ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx !If either n or incx are not positive, the routine returns 0. if ( n <= 0 . or . incx <= 0 ) then icamax = 0 return end if icamax = minloc ( abs ( real ( x ( 1 : n : incx ))) + abs ( aimag ( x ( 1 : n : incx ))), dim = 1 ) end function pure function izamax ( n , x , incx ) integer , parameter :: wp = REAL64 integer :: izamax complex ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx !If either n or incx are not positive, the routine returns 0. if ( n <= 0 . or . incx <= 0 ) then izamax = 0 return end if izamax = minloc ( abs ( real ( x ( 1 : n : incx ))) + abs ( aimag ( x ( 1 : n : incx ))), dim = 1 ) end function pure function isamin ( n , x , incx ) integer , parameter :: wp = REAL32 integer :: isamin real ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx !If either n or incx are not positive, the routine returns 0. if ( n <= 0 . or . incx <= 0 ) then isamin = 0 return end if isamin = minloc ( x ( 1 : n : incx ), dim = 1 ) end function pure function idamin ( n , x , incx ) integer , parameter :: wp = REAL64 integer :: idamin real ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx !If either n or incx are not positive, the routine returns 0. if ( n <= 0 . or . incx <= 0 ) then idamin = 0 return end if idamin = minloc ( x ( 1 : n : incx ), dim = 1 ) end function pure function icamin ( n , x , incx ) integer , parameter :: wp = REAL32 integer :: icamin complex ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx !If either n or incx are not positive, the routine returns 0. if ( n <= 0 . or . incx <= 0 ) then icamin = 0 return end if icamin = minloc ( abs ( real ( x ( 1 : n : incx ))) + abs ( aimag ( x ( 1 : n : incx ))), dim = 1 ) end function pure function izamin ( n , x , incx ) integer , parameter :: wp = REAL64 integer :: izamin complex ( wp ), intent ( in ) :: x ( * ) integer , intent ( in ) :: n integer , intent ( in ) :: incx !If either n or incx are not positive, the routine returns 0. if ( n <= 0 . or . incx <= 0 ) then izamin = 0 return end if izamin = minloc ( abs ( real ( x ( 1 : n : incx ))) + abs ( aimag ( x ( 1 : n : incx ))), dim = 1 ) end function end module","tags":"","loc":"sourcefile/blas.f90.html"},{"title":"blas.f90 – MFI - Modern Fortran Interfaces","text":"Source Code !> Modern fortran interfaces for BLAS module mfi_blas use iso_fortran_env use f77_blas use f77_blas , only : mfi_rotg => f77_rotg use f77_blas , only : mfi_rotmg => f77_rotmg implicit none ! BLAS level 1 interface mfi_asum module procedure mfi_sasum module procedure mfi_dasum module procedure mfi_scasum module procedure mfi_dzasum end interface interface mfi_nrm2 module procedure mfi_snrm2 module procedure mfi_dnrm2 module procedure mfi_scnrm2 module procedure mfi_dznrm2 end interface interface mfi_axpy module procedure mfi_saxpy module procedure mfi_daxpy module procedure mfi_caxpy module procedure mfi_zaxpy end interface interface mfi_copy module procedure mfi_scopy module procedure mfi_dcopy module procedure mfi_ccopy module procedure mfi_zcopy end interface interface mfi_dot module procedure mfi_sdot module procedure mfi_ddot end interface interface mfi_dotu module procedure mfi_cdotu module procedure mfi_zdotu end interface interface mfi_dotc module procedure mfi_cdotc module procedure mfi_zdotc end interface interface mfi_rot module procedure mfi_srot module procedure mfi_drot module procedure mfi_crot module procedure mfi_zrot module procedure mfi_csrot module procedure mfi_zdrot end interface !$:mfi_interface('?rotg',  DEFAULT_TYPES) interface mfi_rotm module procedure mfi_srotm module procedure mfi_drotm end interface !$:mfi_interface('?rotmg', REAL_TYPES) interface mfi_scal module procedure mfi_sscal module procedure mfi_dscal module procedure mfi_cscal module procedure mfi_zscal module procedure mfi_csscal module procedure mfi_zdscal end interface interface mfi_swap module procedure mfi_sswap module procedure mfi_dswap module procedure mfi_cswap module procedure mfi_zswap end interface ! BLAS level 2 interface mfi_gbmv module procedure mfi_sgbmv module procedure mfi_dgbmv module procedure mfi_cgbmv module procedure mfi_zgbmv end interface interface mfi_gemv module procedure mfi_sgemv module procedure mfi_dgemv module procedure mfi_cgemv module procedure mfi_zgemv end interface interface mfi_ger module procedure mfi_sger module procedure mfi_dger end interface interface mfi_gerc module procedure mfi_cgerc module procedure mfi_zgerc end interface interface mfi_geru module procedure mfi_cgeru module procedure mfi_zgeru end interface interface mfi_hbmv module procedure mfi_chbmv module procedure mfi_zhbmv end interface interface mfi_hemv module procedure mfi_chemv module procedure mfi_zhemv end interface interface mfi_her module procedure mfi_cher module procedure mfi_zher end interface interface mfi_her2 module procedure mfi_cher2 module procedure mfi_zher2 end interface interface mfi_hpmv module procedure mfi_chpmv module procedure mfi_zhpmv end interface interface mfi_hpr module procedure mfi_chpr module procedure mfi_zhpr end interface interface mfi_hpr2 module procedure mfi_chpr2 module procedure mfi_zhpr2 end interface interface mfi_sbmv module procedure mfi_ssbmv module procedure mfi_dsbmv end interface interface mfi_spmv module procedure mfi_sspmv module procedure mfi_dspmv end interface interface mfi_spr module procedure mfi_sspr module procedure mfi_dspr end interface interface mfi_spr2 module procedure mfi_sspr2 module procedure mfi_dspr2 end interface interface mfi_symv module procedure mfi_ssymv module procedure mfi_dsymv end interface interface mfi_syr module procedure mfi_ssyr module procedure mfi_dsyr end interface interface mfi_syr2 module procedure mfi_ssyr2 module procedure mfi_dsyr2 end interface interface mfi_tbmv module procedure mfi_stbmv module procedure mfi_dtbmv module procedure mfi_ctbmv module procedure mfi_ztbmv end interface interface mfi_tbsv module procedure mfi_stbsv module procedure mfi_dtbsv module procedure mfi_ctbsv module procedure mfi_ztbsv end interface interface mfi_tpmv module procedure mfi_stpmv module procedure mfi_dtpmv module procedure mfi_ctpmv module procedure mfi_ztpmv end interface interface mfi_tpsv module procedure mfi_stpsv module procedure mfi_dtpsv module procedure mfi_ctpsv module procedure mfi_ztpsv end interface interface mfi_trmv module procedure mfi_strmv module procedure mfi_dtrmv module procedure mfi_ctrmv module procedure mfi_ztrmv end interface interface mfi_trsv module procedure mfi_strsv module procedure mfi_dtrsv module procedure mfi_ctrsv module procedure mfi_ztrsv end interface ! BLAS level 3 interface mfi_gemm module procedure mfi_sgemm module procedure mfi_dgemm module procedure mfi_cgemm module procedure mfi_zgemm end interface interface mfi_hemm module procedure mfi_chemm module procedure mfi_zhemm end interface interface mfi_herk module procedure mfi_cherk module procedure mfi_zherk end interface interface mfi_her2k module procedure mfi_cher2k module procedure mfi_zher2k end interface interface mfi_symm module procedure mfi_ssymm module procedure mfi_dsymm end interface interface mfi_syrk module procedure mfi_ssyrk module procedure mfi_dsyrk end interface interface mfi_syr2k module procedure mfi_ssyr2k module procedure mfi_dsyr2k end interface interface mfi_trmm module procedure mfi_strmm module procedure mfi_dtrmm module procedure mfi_ctrmm module procedure mfi_ztrmm end interface interface mfi_trsm module procedure mfi_strsm module procedure mfi_dtrsm module procedure mfi_ctrsm module procedure mfi_ztrsm end interface ! Extensions ! BLAS level 1 - Utils / Extensions interface mfi_iamax module procedure mfi_isamax module procedure mfi_idamax module procedure mfi_icamax module procedure mfi_izamax end interface interface mfi_iamin module procedure mfi_isamin module procedure mfi_idamin module procedure mfi_icamin module procedure mfi_izamin end interface interface mfi_lamch module procedure mfi_slamch module procedure mfi_dlamch end interface contains ! BLAS level 1 pure function mfi_snrm2 ( x , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx real ( wp ) :: mfi_snrm2 integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_snrm2 = snrm2 ( n , x , local_incx ) end function pure function mfi_dnrm2 ( x , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx real ( wp ) :: mfi_dnrm2 integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_dnrm2 = dnrm2 ( n , x , local_incx ) end function pure function mfi_scnrm2 ( x , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx real ( wp ) :: mfi_scnrm2 integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_scnrm2 = scnrm2 ( n , x , local_incx ) end function pure function mfi_dznrm2 ( x , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx real ( wp ) :: mfi_dznrm2 integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_dznrm2 = dznrm2 ( n , x , local_incx ) end function pure function mfi_sasum ( x , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx real ( wp ) :: mfi_sasum integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_sasum = sasum ( n , x , local_incx ) end function pure function mfi_dasum ( x , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx real ( wp ) :: mfi_dasum integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_dasum = dasum ( n , x , local_incx ) end function pure function mfi_scasum ( x , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx real ( wp ) :: mfi_scasum integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_scasum = scasum ( n , x , local_incx ) end function pure function mfi_dzasum ( x , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx real ( wp ) :: mfi_dzasum integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_dzasum = dzasum ( n , x , local_incx ) end function pure subroutine mfi_saxpy ( x , y , a , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ), optional :: a real ( wp ) :: local_a integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( a )) then local_a = a else local_a = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call saxpy ( n , local_a , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_daxpy ( x , y , a , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ), optional :: a real ( wp ) :: local_a integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( a )) then local_a = a else local_a = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call daxpy ( n , local_a , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_caxpy ( x , y , a , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) complex ( wp ), intent ( in ), optional :: a complex ( wp ) :: local_a integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( a )) then local_a = a else local_a = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call caxpy ( n , local_a , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_zaxpy ( x , y , a , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) complex ( wp ), intent ( in ), optional :: a complex ( wp ) :: local_a integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( a )) then local_a = a else local_a = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call zaxpy ( n , local_a , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_scopy ( x , y , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call scopy ( n , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_dcopy ( x , y , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call dcopy ( n , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_ccopy ( x , y , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call ccopy ( n , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_zcopy ( x , y , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call zcopy ( n , x , local_incx , y , local_incy ) end subroutine pure function mfi_sdot ( x , y , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ) :: mfi_sdot real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: y (:) integer :: n integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) mfi_sdot = sdot ( n , x , local_incx , y , local_incy ) end function pure function mfi_ddot ( x , y , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ) :: mfi_ddot real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: y (:) integer :: n integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) mfi_ddot = ddot ( n , x , local_incx , y , local_incy ) end function pure function mfi_cdotu ( x , y , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ) :: mfi_cdotu complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) integer :: n integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) mfi_cdotu = cdotu ( n , x , local_incx , y , local_incy ) end function pure function mfi_zdotu ( x , y , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ) :: mfi_zdotu complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) integer :: n integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) mfi_zdotu = zdotu ( n , x , local_incx , y , local_incy ) end function pure function mfi_cdotc ( x , y , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ) :: mfi_cdotc complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) integer :: n integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) mfi_cdotc = cdotc ( n , x , local_incx , y , local_incy ) end function pure function mfi_zdotc ( x , y , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ) :: mfi_zdotc complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) integer :: n integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) mfi_zdotc = zdotc ( n , x , local_incx , y , local_incy ) end function !> Given two vectors x and y, !> each vector element of these vectors is replaced as follows: !>```fortran !> xi = c*xi + s*yi !> yi = c*yi - s*xi !>``` pure subroutine mfi_srot ( x , y , c , s , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: x (:) real ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: c real ( wp ), intent ( in ) :: s integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call srot ( n , x , local_incx , y , local_incy , c , s ) end subroutine !> Given two vectors x and y, !> each vector element of these vectors is replaced as follows: !>```fortran !> xi = c*xi + s*yi !> yi = c*yi - s*xi !>``` pure subroutine mfi_drot ( x , y , c , s , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: x (:) real ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: c real ( wp ), intent ( in ) :: s integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call drot ( n , x , local_incx , y , local_incy , c , s ) end subroutine !> Given two vectors x and y, !> each vector element of these vectors is replaced as follows: !>```fortran !> xi = c*xi + s*yi !> yi = c*yi - conj(s)*xi !>``` pure subroutine mfi_crot ( x , y , c , s , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: c complex ( wp ), intent ( in ) :: s integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call crot ( n , x , local_incx , y , local_incy , c , s ) end subroutine !> Given two vectors x and y, !> each vector element of these vectors is replaced as follows: !>```fortran !> xi = c*xi + s*yi !> yi = c*yi - conj(s)*xi !>``` pure subroutine mfi_zrot ( x , y , c , s , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: c complex ( wp ), intent ( in ) :: s integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call zrot ( n , x , local_incx , y , local_incy , c , s ) end subroutine !> Given two vectors x and y, !> each vector element of these vectors is replaced as follows: !>```fortran !> xi = c*xi + s*yi !> yi = c*yi - conj(s)*xi !>``` pure subroutine mfi_csrot ( x , y , c , s , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: c real ( wp ), intent ( in ) :: s integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call csrot ( n , x , local_incx , y , local_incy , c , s ) end subroutine !> Given two vectors x and y, !> each vector element of these vectors is replaced as follows: !>```fortran !> xi = c*xi + s*yi !> yi = c*yi - conj(s)*xi !>``` pure subroutine mfi_zdrot ( x , y , c , s , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: c real ( wp ), intent ( in ) :: s integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call zdrot ( n , x , local_incx , y , local_incy , c , s ) end subroutine !$:mfi_interface('?rotg',  DEFAULT_TYPES) pure subroutine mfi_srotm ( x , y , param , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: x (:) real ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: param ( 5 ) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call srotm ( n , x , local_incx , y , local_incy , param ) end subroutine pure subroutine mfi_drotm ( x , y , param , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: x (:) real ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: param ( 5 ) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call drotm ( n , x , local_incx , y , local_incy , param ) end subroutine !$:mfi_implement('?rotmg', REAL_TYPES, rotmg) !> MFI_SSCAL scales a vector by a constant. pure subroutine mfi_sscal ( x , a , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: x (:) real ( wp ), intent ( in ) :: a integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call sscal ( n , a , x , local_incx ) end subroutine !> MFI_DSCAL scales a vector by a constant. pure subroutine mfi_dscal ( x , a , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: x (:) real ( wp ), intent ( in ) :: a integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call dscal ( n , a , x , local_incx ) end subroutine !> MFI_CSCAL scales a vector by a constant. pure subroutine mfi_cscal ( x , a , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: x (:) complex ( wp ), intent ( in ) :: a integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call cscal ( n , a , x , local_incx ) end subroutine !> MFI_ZSCAL scales a vector by a constant. pure subroutine mfi_zscal ( x , a , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: x (:) complex ( wp ), intent ( in ) :: a integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call zscal ( n , a , x , local_incx ) end subroutine !> MFI_CSSCAL scales a vector by a constant. pure subroutine mfi_csscal ( x , a , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: x (:) real ( wp ), intent ( in ) :: a integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call csscal ( n , a , x , local_incx ) end subroutine !> MFI_ZDSCAL scales a vector by a constant. pure subroutine mfi_zdscal ( x , a , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: x (:) real ( wp ), intent ( in ) :: a integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call zdscal ( n , a , x , local_incx ) end subroutine pure subroutine mfi_sswap ( x , y , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call sswap ( n , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_dswap ( x , y , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call dswap ( n , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_cswap ( x , y , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call cswap ( n , x , local_incx , y , local_incy ) end subroutine pure subroutine mfi_zswap ( x , y , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if N = size ( X ) call zswap ( n , x , local_incx , y , local_incy ) end subroutine ! BLAS level 2 pure subroutine mfi_sgbmv ( a , x , y , kl , m , alpha , beta , trans , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: trans character :: local_trans real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: kl integer :: local_kl integer , intent ( in ), optional :: m integer :: local_m integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , ku , lda n = size ( a , 2 ) lda = max ( 1 , size ( a , 1 )) if ( present ( kl )) then local_kl = kl else local_kl = ( lda - 1 ) / 2 end if if ( present ( m )) then local_m = m else local_m = n end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if ku = lda - local_kl - 1 call sgbmv ( local_trans , local_m , n , local_kl , ku , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_dgbmv ( a , x , y , kl , m , alpha , beta , trans , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: trans character :: local_trans real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: kl integer :: local_kl integer , intent ( in ), optional :: m integer :: local_m integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , ku , lda n = size ( a , 2 ) lda = max ( 1 , size ( a , 1 )) if ( present ( kl )) then local_kl = kl else local_kl = ( lda - 1 ) / 2 end if if ( present ( m )) then local_m = m else local_m = n end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if ku = lda - local_kl - 1 call dgbmv ( local_trans , local_m , n , local_kl , ku , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_cgbmv ( a , x , y , kl , m , alpha , beta , trans , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: trans character :: local_trans complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: kl integer :: local_kl integer , intent ( in ), optional :: m integer :: local_m integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , ku , lda n = size ( a , 2 ) lda = max ( 1 , size ( a , 1 )) if ( present ( kl )) then local_kl = kl else local_kl = ( lda - 1 ) / 2 end if if ( present ( m )) then local_m = m else local_m = n end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if ku = lda - local_kl - 1 call cgbmv ( local_trans , local_m , n , local_kl , ku , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_zgbmv ( a , x , y , kl , m , alpha , beta , trans , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: trans character :: local_trans complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: kl integer :: local_kl integer , intent ( in ), optional :: m integer :: local_m integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , ku , lda n = size ( a , 2 ) lda = max ( 1 , size ( a , 1 )) if ( present ( kl )) then local_kl = kl else local_kl = ( lda - 1 ) / 2 end if if ( present ( m )) then local_m = m else local_m = n end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if ku = lda - local_kl - 1 call zgbmv ( local_trans , local_m , n , local_kl , ku , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_sgemv ( a , x , y , trans , alpha , beta , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: trans character :: local_trans real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call sgemv ( local_trans , m , n , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_dgemv ( a , x , y , trans , alpha , beta , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: trans character :: local_trans real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call dgemv ( local_trans , m , n , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_cgemv ( a , x , y , trans , alpha , beta , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: trans character :: local_trans complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call cgemv ( local_trans , m , n , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_zgemv ( a , x , y , trans , alpha , beta , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: trans character :: local_trans complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call zgemv ( local_trans , m , n , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_sger ( a , x , y , alpha , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call sger ( m , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_dger ( a , x , y , alpha , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call dger ( m , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_cgerc ( a , x , y , alpha , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call cgerc ( m , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_zgerc ( a , x , y , alpha , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call zgerc ( m , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_cgeru ( a , x , y , alpha , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call cgeru ( m , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_zgeru ( a , x , y , alpha , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: m , n , lda if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if m = size ( a , 1 ) n = size ( a , 2 ) lda = max ( 1 , m ) call zgeru ( m , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_chbmv ( a , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call chbmv ( local_uplo , n , k , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_zhbmv ( a , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call zhbmv ( local_uplo , n , k , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_chemv ( a , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call chemv ( local_uplo , n , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_zhemv ( a , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call zhemv ( local_uplo , n , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_cher ( a , x , uplo , alpha , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call cher ( local_uplo , n , local_alpha , x , local_incx , a , lda ) end subroutine pure subroutine mfi_zher ( a , x , uplo , alpha , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call zher ( local_uplo , n , local_alpha , x , local_incx , a , lda ) end subroutine pure subroutine mfi_cher2 ( a , x , y , uplo , alpha , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) complex ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call cher2 ( local_uplo , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_zher2 ( a , x , y , uplo , alpha , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) complex ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call zher2 ( local_uplo , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_chpmv ( ap , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: ap (:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call chpmv ( local_uplo , n , local_alpha , ap , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_zhpmv ( ap , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: ap (:) complex ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call zhpmv ( local_uplo , n , local_alpha , ap , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_chpr ( ap , x , uplo , alpha , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: ap (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call chpr ( local_uplo , n , local_alpha , x , local_incx , ap ) end subroutine pure subroutine mfi_zhpr ( ap , x , uplo , alpha , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: ap (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call zhpr ( local_uplo , n , local_alpha , x , local_incx , ap ) end subroutine pure subroutine mfi_chpr2 ( ap , x , y , uplo , alpha , incx , incy ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) complex ( wp ), intent ( inout ) :: ap (:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call chpr2 ( local_uplo , n , local_alpha , x , local_incx , y , local_incy , ap ) end subroutine pure subroutine mfi_zhpr2 ( ap , x , y , uplo , alpha , incx , incy ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( in ) :: y (:) complex ( wp ), intent ( inout ) :: ap (:) character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call zhpr2 ( local_uplo , n , local_alpha , x , local_incx , y , local_incy , ap ) end subroutine pure subroutine mfi_ssbmv ( a , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ssbmv ( local_uplo , n , k , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_dsbmv ( a , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dsbmv ( local_uplo , n , k , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_sspmv ( ap , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: ap (:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call sspmv ( local_uplo , n , local_alpha , ap , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_dspmv ( ap , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: ap (:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call dspmv ( local_uplo , n , local_alpha , ap , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_sspr ( ap , x , uplo , alpha , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: ap (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call sspr ( local_uplo , n , local_alpha , x , local_incx , ap ) end subroutine pure subroutine mfi_dspr ( ap , x , uplo , alpha , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: ap (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call dspr ( local_uplo , n , local_alpha , x , local_incx , ap ) end subroutine pure subroutine mfi_sspr2 ( ap , x , y , uplo , alpha , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: ap (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call sspr2 ( local_uplo , n , local_alpha , x , local_incx , y , local_incy , ap ) end subroutine pure subroutine mfi_dspr2 ( ap , x , y , uplo , alpha , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: ap (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if n = size ( x ) call dspr2 ( local_uplo , n , local_alpha , x , local_incx , y , local_incy , ap ) end subroutine pure subroutine mfi_ssymv ( a , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ssymv ( local_uplo , n , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_dsymv ( a , x , y , uplo , alpha , beta , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: y (:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dsymv ( local_uplo , n , local_alpha , a , lda , x , local_incx , local_beta , y , local_incy ) end subroutine pure subroutine mfi_ssyr ( a , x , uplo , alpha , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ssyr ( local_uplo , n , local_alpha , x , local_incx , a , lda ) end subroutine pure subroutine mfi_dsyr ( a , x , uplo , alpha , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dsyr ( local_uplo , n , local_alpha , x , local_incx , a , lda ) end subroutine pure subroutine mfi_ssyr2 ( a , x , y , uplo , alpha , incx , incy ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ssyr2 ( local_uplo , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_dsyr2 ( a , x , y , uplo , alpha , incx , incy ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer , intent ( in ), optional :: incx integer :: local_incx integer , intent ( in ), optional :: incy integer :: local_incy integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if if ( present ( incy )) then local_incy = incy else local_incy = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dsyr2 ( local_uplo , n , local_alpha , x , local_incx , y , local_incy , a , lda ) end subroutine pure subroutine mfi_stbmv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call stbmv ( local_uplo , local_trans , local_diag , n , k , a , lda , x , local_incx ) end subroutine pure subroutine mfi_dtbmv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dtbmv ( local_uplo , local_trans , local_diag , n , k , a , lda , x , local_incx ) end subroutine pure subroutine mfi_ctbmv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ctbmv ( local_uplo , local_trans , local_diag , n , k , a , lda , x , local_incx ) end subroutine pure subroutine mfi_ztbmv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ztbmv ( local_uplo , local_trans , local_diag , n , k , a , lda , x , local_incx ) end subroutine pure subroutine mfi_stbsv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call stbsv ( local_uplo , local_trans , local_diag , n , k , a , lda , x , local_incx ) end subroutine pure subroutine mfi_dtbsv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dtbsv ( local_uplo , local_trans , local_diag , n , k , a , lda , x , local_incx ) end subroutine pure subroutine mfi_ctbsv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ctbsv ( local_uplo , local_trans , local_diag , n , k , a , lda , x , local_incx ) end subroutine pure subroutine mfi_ztbsv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , k , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if k = size ( a , 1 ) - 1 lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ztbsv ( local_uplo , local_trans , local_diag , n , k , a , lda , x , local_incx ) end subroutine pure subroutine mfi_stpmv ( ap , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: ap (:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call stpmv ( local_uplo , local_trans , local_diag , n , ap , x , local_incx ) end subroutine pure subroutine mfi_dtpmv ( ap , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: ap (:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call dtpmv ( local_uplo , local_trans , local_diag , n , ap , x , local_incx ) end subroutine pure subroutine mfi_ctpmv ( ap , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: ap (:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call ctpmv ( local_uplo , local_trans , local_diag , n , ap , x , local_incx ) end subroutine pure subroutine mfi_ztpmv ( ap , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: ap (:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call ztpmv ( local_uplo , local_trans , local_diag , n , ap , x , local_incx ) end subroutine pure subroutine mfi_stpsv ( ap , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: ap (:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call stpsv ( local_uplo , local_trans , local_diag , n , ap , x , local_incx ) end subroutine pure subroutine mfi_dtpsv ( ap , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: ap (:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call dtpsv ( local_uplo , local_trans , local_diag , n , ap , x , local_incx ) end subroutine pure subroutine mfi_ctpsv ( ap , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: ap (:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call ctpsv ( local_uplo , local_trans , local_diag , n , ap , x , local_incx ) end subroutine pure subroutine mfi_ztpsv ( ap , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: ap (:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) call ztpsv ( local_uplo , local_trans , local_diag , n , ap , x , local_incx ) end subroutine pure subroutine mfi_strmv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call strmv ( local_uplo , local_trans , local_diag , n , a , lda , x , local_incx ) end subroutine pure subroutine mfi_dtrmv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dtrmv ( local_uplo , local_trans , local_diag , n , a , lda , x , local_incx ) end subroutine pure subroutine mfi_ctrmv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ctrmv ( local_uplo , local_trans , local_diag , n , a , lda , x , local_incx ) end subroutine pure subroutine mfi_ztrmv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ztrmv ( local_uplo , local_trans , local_diag , n , a , lda , x , local_incx ) end subroutine pure subroutine mfi_strsv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call strsv ( local_uplo , local_trans , local_diag , n , a , lda , x , local_incx ) end subroutine pure subroutine mfi_dtrsv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dtrsv ( local_uplo , local_trans , local_diag , n , a , lda , x , local_incx ) end subroutine pure subroutine mfi_ctrsv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ctrsv ( local_uplo , local_trans , local_diag , n , a , lda , x , local_incx ) end subroutine pure subroutine mfi_ztrsv ( a , x , uplo , trans , diag , incx ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: x (:) character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: diag character :: local_diag integer , intent ( in ), optional :: incx integer :: local_incx integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( incx )) then local_incx = incx else local_incx = 1 end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call ztrsv ( local_uplo , local_trans , local_diag , n , a , lda , x , local_incx ) end subroutine ! BLAS level 3 pure subroutine mfi_sgemm ( a , b , c , transa , transb , alpha , beta ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: b (:,:) real ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: transb character :: local_transb real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: m , n , k , lda , ldb , ldc if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( transb )) then local_transb = transb else local_transb = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) m = size ( c , 1 ) n = size ( c , 2 ) if ( local_transa == 'N' . or . local_transa == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if call sgemm ( local_transa , local_transb , m , n , k , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_dgemm ( a , b , c , transa , transb , alpha , beta ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: b (:,:) real ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: transb character :: local_transb real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: m , n , k , lda , ldb , ldc if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( transb )) then local_transb = transb else local_transb = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) m = size ( c , 1 ) n = size ( c , 2 ) if ( local_transa == 'N' . or . local_transa == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if call dgemm ( local_transa , local_transb , m , n , k , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_cgemm ( a , b , c , transa , transb , alpha , beta ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: b (:,:) complex ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: transb character :: local_transb complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer :: m , n , k , lda , ldb , ldc if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( transb )) then local_transb = transb else local_transb = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) m = size ( c , 1 ) n = size ( c , 2 ) if ( local_transa == 'N' . or . local_transa == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if call cgemm ( local_transa , local_transb , m , n , k , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_zgemm ( a , b , c , transa , transb , alpha , beta ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: b (:,:) complex ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: transb character :: local_transb complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer :: m , n , k , lda , ldb , ldc if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( transb )) then local_transb = transb else local_transb = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) m = size ( c , 1 ) n = size ( c , 2 ) if ( local_transa == 'N' . or . local_transa == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if call zgemm ( local_transa , local_transb , m , n , k , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_chemm ( a , b , c , side , uplo , alpha , beta ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: b (:,:) complex ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer :: m , n , lda , ldb , ldc if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) m = size ( c , 1 ) n = size ( c , 2 ) call chemm ( local_side , local_uplo , m , n , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_zhemm ( a , b , c , side , uplo , alpha , beta ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: b (:,:) complex ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha complex ( wp ), intent ( in ), optional :: beta complex ( wp ) :: local_beta integer :: m , n , lda , ldb , ldc if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) m = size ( c , 1 ) n = size ( c , 2 ) call zhemm ( local_side , local_uplo , m , n , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_cherk ( a , c , uplo , trans , alpha , beta ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: n , k , lda , ldc if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if n = size ( c , 2 ) if ( local_trans == 'N' . or . local_trans == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if lda = max ( 1 , size ( a , 1 )) ldc = max ( 1 , size ( c , 1 )) call cherk ( local_uplo , local_trans , n , k , local_alpha , a , lda , local_beta , c , ldc ) end subroutine pure subroutine mfi_zherk ( a , c , uplo , trans , alpha , beta ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: n , k , lda , ldc if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if n = size ( c , 2 ) if ( local_trans == 'N' . or . local_trans == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if lda = max ( 1 , size ( a , 1 )) ldc = max ( 1 , size ( c , 1 )) call zherk ( local_uplo , local_trans , n , k , local_alpha , a , lda , local_beta , c , ldc ) end subroutine pure subroutine mfi_cher2k ( a , b , c , uplo , trans , alpha , beta ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: b (:,:) complex ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: n , k , lda , ldb , ldc if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if n = size ( c , 2 ) if ( local_trans == 'N' . or . local_trans == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) call cher2k ( local_uplo , local_trans , n , k , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_zher2k ( a , b , c , uplo , trans , alpha , beta ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( in ) :: b (:,:) complex ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: n , k , lda , ldb , ldc if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if n = size ( c , 2 ) if ( local_trans == 'N' . or . local_trans == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) call zher2k ( local_uplo , local_trans , n , k , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_ssymm ( a , b , c , side , uplo , alpha , beta ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: b (:,:) real ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: m , n , lda , ldb , ldc if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) m = size ( c , 1 ) n = size ( c , 2 ) call ssymm ( local_side , local_uplo , m , n , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_dsymm ( a , b , c , side , uplo , alpha , beta ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: b (:,:) real ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: m , n , lda , ldb , ldc if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) m = size ( c , 1 ) n = size ( c , 2 ) call dsymm ( local_side , local_uplo , m , n , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_ssyrk ( a , c , uplo , trans , alpha , beta ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: n , k , lda , ldc if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if n = size ( c , 2 ) if ( local_trans == 'N' . or . local_trans == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if lda = max ( 1 , size ( a , 1 )) ldc = max ( 1 , size ( c , 1 )) call ssyrk ( local_uplo , local_trans , n , k , local_alpha , a , lda , local_beta , c , ldc ) end subroutine pure subroutine mfi_dsyrk ( a , c , uplo , trans , alpha , beta ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: n , k , lda , ldc if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if n = size ( c , 2 ) if ( local_trans == 'N' . or . local_trans == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if lda = max ( 1 , size ( a , 1 )) ldc = max ( 1 , size ( c , 1 )) call dsyrk ( local_uplo , local_trans , n , k , local_alpha , a , lda , local_beta , c , ldc ) end subroutine pure subroutine mfi_ssyr2k ( a , b , c , uplo , trans , alpha , beta ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: b (:,:) real ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: n , k , lda , ldb , ldc if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if n = size ( c , 2 ) if ( local_trans == 'N' . or . local_trans == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) call ssyr2k ( local_uplo , local_trans , n , k , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_dsyr2k ( a , b , c , uplo , trans , alpha , beta ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( in ) :: b (:,:) real ( wp ), intent ( inout ) :: c (:,:) character , intent ( in ), optional :: trans character :: local_trans character , intent ( in ), optional :: uplo character :: local_uplo real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha real ( wp ), intent ( in ), optional :: beta real ( wp ) :: local_beta integer :: n , k , lda , ldb , ldc if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if if ( present ( beta )) then local_beta = beta else local_beta = 0.0_wp end if n = size ( c , 2 ) if ( local_trans == 'N' . or . local_trans == 'n' ) then k = size ( a , 2 ) else k = size ( a , 1 ) end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) ldc = max ( 1 , size ( c , 1 )) call dsyr2k ( local_uplo , local_trans , n , k , local_alpha , a , lda , b , ldb , local_beta , c , ldc ) end subroutine pure subroutine mfi_strmm ( a , b , side , uplo , transa , diag , alpha ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: diag character :: local_diag real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer :: m , n , lda , ldb if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if m = size ( b , 1 ) n = size ( b , 2 ) lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) call strmm ( local_side , local_uplo , local_transa , local_diag , m , n , local_alpha , a , lda , b , ldb ) end subroutine pure subroutine mfi_dtrmm ( a , b , side , uplo , transa , diag , alpha ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: diag character :: local_diag real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer :: m , n , lda , ldb if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if m = size ( b , 1 ) n = size ( b , 2 ) lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) call dtrmm ( local_side , local_uplo , local_transa , local_diag , m , n , local_alpha , a , lda , b , ldb ) end subroutine pure subroutine mfi_ctrmm ( a , b , side , uplo , transa , diag , alpha ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: diag character :: local_diag complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer :: m , n , lda , ldb if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if m = size ( b , 1 ) n = size ( b , 2 ) lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) call ctrmm ( local_side , local_uplo , local_transa , local_diag , m , n , local_alpha , a , lda , b , ldb ) end subroutine pure subroutine mfi_ztrmm ( a , b , side , uplo , transa , diag , alpha ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: diag character :: local_diag complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer :: m , n , lda , ldb if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if m = size ( b , 1 ) n = size ( b , 2 ) lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) call ztrmm ( local_side , local_uplo , local_transa , local_diag , m , n , local_alpha , a , lda , b , ldb ) end subroutine pure subroutine mfi_strsm ( a , b , side , uplo , transa , diag , alpha ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: diag character :: local_diag real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer :: m , n , lda , ldb if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if m = size ( b , 1 ) n = size ( b , 2 ) lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) call strsm ( local_side , local_uplo , local_transa , local_diag , m , n , local_alpha , a , lda , b , ldb ) end subroutine pure subroutine mfi_dtrsm ( a , b , side , uplo , transa , diag , alpha ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: diag character :: local_diag real ( wp ), intent ( in ), optional :: alpha real ( wp ) :: local_alpha integer :: m , n , lda , ldb if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if m = size ( b , 1 ) n = size ( b , 2 ) lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) call dtrsm ( local_side , local_uplo , local_transa , local_diag , m , n , local_alpha , a , lda , b , ldb ) end subroutine pure subroutine mfi_ctrsm ( a , b , side , uplo , transa , diag , alpha ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: diag character :: local_diag complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer :: m , n , lda , ldb if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if m = size ( b , 1 ) n = size ( b , 2 ) lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) call ctrsm ( local_side , local_uplo , local_transa , local_diag , m , n , local_alpha , a , lda , b , ldb ) end subroutine pure subroutine mfi_ztrsm ( a , b , side , uplo , transa , diag , alpha ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: side character :: local_side character , intent ( in ), optional :: uplo character :: local_uplo character , intent ( in ), optional :: transa character :: local_transa character , intent ( in ), optional :: diag character :: local_diag complex ( wp ), intent ( in ), optional :: alpha complex ( wp ) :: local_alpha integer :: m , n , lda , ldb if ( present ( side )) then local_side = side else local_side = 'L' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if if ( present ( transa )) then local_transa = transa else local_transa = 'N' end if if ( present ( diag )) then local_diag = diag else local_diag = 'N' end if if ( present ( alpha )) then local_alpha = alpha else local_alpha = 1.0_wp end if m = size ( b , 1 ) n = size ( b , 2 ) lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) call ztrsm ( local_side , local_uplo , local_transa , local_diag , m , n , local_alpha , a , lda , b , ldb ) end subroutine ! Extensions ! BLAS level 1 - Utils / Extensions pure function mfi_isamax ( x , incx ) integer , parameter :: wp = REAL32 integer :: mfi_isamax real ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_isamax = isamax ( n , x , local_incx ) end function pure function mfi_idamax ( x , incx ) integer , parameter :: wp = REAL64 integer :: mfi_idamax real ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_idamax = idamax ( n , x , local_incx ) end function pure function mfi_icamax ( x , incx ) integer , parameter :: wp = REAL32 integer :: mfi_icamax complex ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_icamax = icamax ( n , x , local_incx ) end function pure function mfi_izamax ( x , incx ) integer , parameter :: wp = REAL64 integer :: mfi_izamax complex ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_izamax = izamax ( n , x , local_incx ) end function pure function mfi_isamin ( x , incx ) integer , parameter :: wp = REAL32 integer :: mfi_isamin real ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_isamin = isamin ( n , x , local_incx ) end function pure function mfi_idamin ( x , incx ) integer , parameter :: wp = REAL64 integer :: mfi_idamin real ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_idamin = idamin ( n , x , local_incx ) end function pure function mfi_icamin ( x , incx ) integer , parameter :: wp = REAL32 integer :: mfi_icamin complex ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_icamin = icamin ( n , x , local_incx ) end function pure function mfi_izamin ( x , incx ) integer , parameter :: wp = REAL64 integer :: mfi_izamin complex ( wp ), intent ( in ) :: x (:) integer , intent ( in ), optional :: incx integer :: local_incx integer :: n if ( present ( incx )) then local_incx = incx else local_incx = 1 end if n = size ( x ) mfi_izamin = izamin ( n , x , local_incx ) end function pure function mfi_slamch ( cmach , kind ) result ( res ) integer , parameter :: wp = REAL32 character , intent ( in ) :: cmach real ( wp ), intent ( in ) :: kind !! Just a kind placeholder real ( wp ) :: res res = slamch ( cmach ) end function pure function mfi_dlamch ( cmach , kind ) result ( res ) integer , parameter :: wp = REAL64 character , intent ( in ) :: cmach real ( wp ), intent ( in ) :: kind !! Just a kind placeholder real ( wp ) :: res res = dlamch ( cmach ) end function end module","tags":"","loc":"sourcefile/blas.f90~2.html"},{"title":"lapack.f90 – MFI - Modern Fortran Interfaces","text":"Source Code !> Modern fortran interfaces for LAPACK module mfi_lapack use iso_fortran_env use f77_lapack use f77_lapack , only : mfi_lartg => f77_lartg implicit none interface mfi_geqrf module procedure mfi_sgeqrf module procedure mfi_dgeqrf module procedure mfi_cgeqrf module procedure mfi_zgeqrf end interface interface mfi_gerqf module procedure mfi_sgerqf module procedure mfi_dgerqf module procedure mfi_cgerqf module procedure mfi_zgerqf end interface interface mfi_getrf module procedure mfi_sgetrf module procedure mfi_dgetrf module procedure mfi_cgetrf module procedure mfi_zgetrf end interface interface mfi_getri module procedure mfi_sgetri module procedure mfi_dgetri module procedure mfi_cgetri module procedure mfi_zgetri end interface interface mfi_getrs module procedure mfi_sgetrs module procedure mfi_dgetrs module procedure mfi_cgetrs module procedure mfi_zgetrs end interface interface mfi_hetrf module procedure mfi_chetrf module procedure mfi_zhetrf end interface interface mfi_hegv module procedure mfi_chegv module procedure mfi_zhegv end interface interface mfi_heevd module procedure mfi_cheevd module procedure mfi_zheevd end interface interface mfi_gesvd module procedure mfi_sgesvd module procedure mfi_dgesvd module procedure mfi_cgesvd module procedure mfi_zgesvd end interface interface mfi_potrf module procedure mfi_spotrf module procedure mfi_dpotrf module procedure mfi_cpotrf module procedure mfi_zpotrf end interface interface mfi_potri module procedure mfi_spotri module procedure mfi_dpotri module procedure mfi_cpotri module procedure mfi_zpotri end interface interface mfi_potrs module procedure mfi_spotrs module procedure mfi_dpotrs module procedure mfi_cpotrs module procedure mfi_zpotrs end interface interface mfi_pocon module procedure mfi_spocon module procedure mfi_dpocon module procedure mfi_cpocon module procedure mfi_zpocon end interface contains pure subroutine mfi_sgeqrf ( a , tau , info ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ), optional , target :: tau (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , lwork , allocation_status , deallocation_status real ( wp ), pointer :: local_tau (:), work (:) real ( wp ), target :: s_work ( 1 ) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( tau )) then local_tau => tau else allocate ( local_tau ( min ( m , n )), stat = allocation_status ) end if ! Retrieve work array size lwork = - 1 call sgeqrf ( m , n , a , lda , local_tau , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call sgeqrf ( m , n , a , lda , local_tau , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) ! Error handling 404 continue if (. not . present ( tau )) then deallocate ( local_tau , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'sgeqrf' , - local_info ) end if end subroutine pure subroutine mfi_dgeqrf ( a , tau , info ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ), optional , target :: tau (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , lwork , allocation_status , deallocation_status real ( wp ), pointer :: local_tau (:), work (:) real ( wp ), target :: s_work ( 1 ) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( tau )) then local_tau => tau else allocate ( local_tau ( min ( m , n )), stat = allocation_status ) end if ! Retrieve work array size lwork = - 1 call dgeqrf ( m , n , a , lda , local_tau , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call dgeqrf ( m , n , a , lda , local_tau , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) ! Error handling 404 continue if (. not . present ( tau )) then deallocate ( local_tau , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'dgeqrf' , - local_info ) end if end subroutine pure subroutine mfi_cgeqrf ( a , tau , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( out ), optional , target :: tau (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , lwork , allocation_status , deallocation_status complex ( wp ), pointer :: local_tau (:), work (:) complex ( wp ), target :: s_work ( 1 ) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( tau )) then local_tau => tau else allocate ( local_tau ( min ( m , n )), stat = allocation_status ) end if ! Retrieve work array size lwork = - 1 call cgeqrf ( m , n , a , lda , local_tau , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call cgeqrf ( m , n , a , lda , local_tau , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) ! Error handling 404 continue if (. not . present ( tau )) then deallocate ( local_tau , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cgeqrf' , - local_info ) end if end subroutine pure subroutine mfi_zgeqrf ( a , tau , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( out ), optional , target :: tau (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , lwork , allocation_status , deallocation_status complex ( wp ), pointer :: local_tau (:), work (:) complex ( wp ), target :: s_work ( 1 ) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( tau )) then local_tau => tau else allocate ( local_tau ( min ( m , n )), stat = allocation_status ) end if ! Retrieve work array size lwork = - 1 call zgeqrf ( m , n , a , lda , local_tau , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call zgeqrf ( m , n , a , lda , local_tau , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) ! Error handling 404 continue if (. not . present ( tau )) then deallocate ( local_tau , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zgeqrf' , - local_info ) end if end subroutine pure subroutine mfi_sgerqf ( a , tau , info ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ), optional , target :: tau (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , lwork , allocation_status , deallocation_status real ( wp ), pointer :: local_tau (:), work (:) real ( wp ), target :: s_work ( 1 ) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( tau )) then local_tau => tau else allocate ( local_tau ( min ( m , n )), stat = allocation_status ) end if ! Retrieve work array size lwork = - 1 call sgerqf ( m , n , a , lda , local_tau , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call sgerqf ( m , n , a , lda , local_tau , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) ! Error handling 404 continue if (. not . present ( tau )) then deallocate ( local_tau , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'sgerqf' , - local_info ) end if end subroutine pure subroutine mfi_dgerqf ( a , tau , info ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ), optional , target :: tau (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , lwork , allocation_status , deallocation_status real ( wp ), pointer :: local_tau (:), work (:) real ( wp ), target :: s_work ( 1 ) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( tau )) then local_tau => tau else allocate ( local_tau ( min ( m , n )), stat = allocation_status ) end if ! Retrieve work array size lwork = - 1 call dgerqf ( m , n , a , lda , local_tau , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call dgerqf ( m , n , a , lda , local_tau , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) ! Error handling 404 continue if (. not . present ( tau )) then deallocate ( local_tau , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'dgerqf' , - local_info ) end if end subroutine pure subroutine mfi_cgerqf ( a , tau , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( out ), optional , target :: tau (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , lwork , allocation_status , deallocation_status complex ( wp ), pointer :: local_tau (:), work (:) complex ( wp ), target :: s_work ( 1 ) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( tau )) then local_tau => tau else allocate ( local_tau ( min ( m , n )), stat = allocation_status ) end if ! Retrieve work array size lwork = - 1 call cgerqf ( m , n , a , lda , local_tau , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call cgerqf ( m , n , a , lda , local_tau , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) ! Error handling 404 continue if (. not . present ( tau )) then deallocate ( local_tau , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cgerqf' , - local_info ) end if end subroutine pure subroutine mfi_zgerqf ( a , tau , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( out ), optional , target :: tau (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , lwork , allocation_status , deallocation_status complex ( wp ), pointer :: local_tau (:), work (:) complex ( wp ), target :: s_work ( 1 ) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( tau )) then local_tau => tau else allocate ( local_tau ( min ( m , n )), stat = allocation_status ) end if ! Retrieve work array size lwork = - 1 call zgerqf ( m , n , a , lda , local_tau , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call zgerqf ( m , n , a , lda , local_tau , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) ! Error handling 404 continue if (. not . present ( tau )) then deallocate ( local_tau , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zgerqf' , - local_info ) end if end subroutine pure subroutine mfi_sgetrf ( a , ipiv , info ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) integer , intent ( out ), optional , target :: ipiv (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , allocation_status , deallocation_status integer , pointer :: local_ipiv (:) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( ipiv )) then local_ipiv => ipiv else allocate ( local_ipiv ( min ( m , n )), stat = allocation_status ) end if if ( allocation_status == 0 ) then call sgetrf ( m , n , a , lda , local_ipiv , local_info ) else local_info = - 1000 end if if (. not . present ( ipiv )) then deallocate ( local_ipiv , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'sgetrf' , - local_info ) end if end subroutine pure subroutine mfi_dgetrf ( a , ipiv , info ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) integer , intent ( out ), optional , target :: ipiv (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , allocation_status , deallocation_status integer , pointer :: local_ipiv (:) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( ipiv )) then local_ipiv => ipiv else allocate ( local_ipiv ( min ( m , n )), stat = allocation_status ) end if if ( allocation_status == 0 ) then call dgetrf ( m , n , a , lda , local_ipiv , local_info ) else local_info = - 1000 end if if (. not . present ( ipiv )) then deallocate ( local_ipiv , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'dgetrf' , - local_info ) end if end subroutine pure subroutine mfi_cgetrf ( a , ipiv , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) integer , intent ( out ), optional , target :: ipiv (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , allocation_status , deallocation_status integer , pointer :: local_ipiv (:) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( ipiv )) then local_ipiv => ipiv else allocate ( local_ipiv ( min ( m , n )), stat = allocation_status ) end if if ( allocation_status == 0 ) then call cgetrf ( m , n , a , lda , local_ipiv , local_info ) else local_info = - 1000 end if if (. not . present ( ipiv )) then deallocate ( local_ipiv , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cgetrf' , - local_info ) end if end subroutine pure subroutine mfi_zgetrf ( a , ipiv , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) integer , intent ( out ), optional , target :: ipiv (:) integer , intent ( out ), optional :: info integer :: local_info integer :: m , n , lda , allocation_status , deallocation_status integer , pointer :: local_ipiv (:) lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) allocation_status = 0 if ( present ( ipiv )) then local_ipiv => ipiv else allocate ( local_ipiv ( min ( m , n )), stat = allocation_status ) end if if ( allocation_status == 0 ) then call zgetrf ( m , n , a , lda , local_ipiv , local_info ) else local_info = - 1000 end if if (. not . present ( ipiv )) then deallocate ( local_ipiv , stat = deallocation_status ) end if if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zgetrf' , - local_info ) end if end subroutine pure subroutine mfi_sgetri ( a , ipiv , info ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) integer , intent ( in ) :: ipiv (:) real ( wp ), pointer :: work (:) real ( wp ) :: s_work ( 1 ) integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , lwork , allocation_status , deallocation_status lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) lwork = - 1 call sgetri ( n , a , lda , ipiv , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) allocate ( work ( lwork ), stat = allocation_status ) if ( allocation_status == 0 ) then call sgetri ( n , a , lda , ipiv , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) 404 continue if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'sgetri' , - local_info ) end if end subroutine pure subroutine mfi_dgetri ( a , ipiv , info ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) integer , intent ( in ) :: ipiv (:) real ( wp ), pointer :: work (:) real ( wp ) :: s_work ( 1 ) integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , lwork , allocation_status , deallocation_status lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) lwork = - 1 call dgetri ( n , a , lda , ipiv , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) allocate ( work ( lwork ), stat = allocation_status ) if ( allocation_status == 0 ) then call dgetri ( n , a , lda , ipiv , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) 404 continue if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'dgetri' , - local_info ) end if end subroutine pure subroutine mfi_cgetri ( a , ipiv , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) integer , intent ( in ) :: ipiv (:) complex ( wp ), pointer :: work (:) complex ( wp ) :: s_work ( 1 ) integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , lwork , allocation_status , deallocation_status lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) lwork = - 1 call cgetri ( n , a , lda , ipiv , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) allocate ( work ( lwork ), stat = allocation_status ) if ( allocation_status == 0 ) then call cgetri ( n , a , lda , ipiv , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) 404 continue if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cgetri' , - local_info ) end if end subroutine pure subroutine mfi_zgetri ( a , ipiv , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) integer , intent ( in ) :: ipiv (:) complex ( wp ), pointer :: work (:) complex ( wp ) :: s_work ( 1 ) integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , lwork , allocation_status , deallocation_status lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) lwork = - 1 call zgetri ( n , a , lda , ipiv , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) allocate ( work ( lwork ), stat = allocation_status ) if ( allocation_status == 0 ) then call zgetri ( n , a , lda , ipiv , work , lwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) 404 continue if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zgetri' , - local_info ) end if end subroutine pure subroutine mfi_sgetrs ( a , ipiv , b , trans , info ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( inout ) :: b (:,:) integer , intent ( in ) :: ipiv (:) integer , intent ( out ), optional :: info integer :: local_info character , intent ( in ), optional :: trans character :: local_trans integer :: n , nrhs , lda , ldb if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) nrhs = size ( b , 2 ) call sgetrs ( local_trans , n , nrhs , a , lda , ipiv , b , ldb , local_info ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'sgetrs' , - local_info ) end if end subroutine pure subroutine mfi_dgetrs ( a , ipiv , b , trans , info ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( inout ) :: b (:,:) integer , intent ( in ) :: ipiv (:) integer , intent ( out ), optional :: info integer :: local_info character , intent ( in ), optional :: trans character :: local_trans integer :: n , nrhs , lda , ldb if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) nrhs = size ( b , 2 ) call dgetrs ( local_trans , n , nrhs , a , lda , ipiv , b , ldb , local_info ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'dgetrs' , - local_info ) end if end subroutine pure subroutine mfi_cgetrs ( a , ipiv , b , trans , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) integer , intent ( in ) :: ipiv (:) integer , intent ( out ), optional :: info integer :: local_info character , intent ( in ), optional :: trans character :: local_trans integer :: n , nrhs , lda , ldb if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) nrhs = size ( b , 2 ) call cgetrs ( local_trans , n , nrhs , a , lda , ipiv , b , ldb , local_info ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cgetrs' , - local_info ) end if end subroutine pure subroutine mfi_zgetrs ( a , ipiv , b , trans , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) integer , intent ( in ) :: ipiv (:) integer , intent ( out ), optional :: info integer :: local_info character , intent ( in ), optional :: trans character :: local_trans integer :: n , nrhs , lda , ldb if ( present ( trans )) then local_trans = trans else local_trans = 'N' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) nrhs = size ( b , 2 ) call zgetrs ( local_trans , n , nrhs , a , lda , ipiv , b , ldb , local_info ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zgetrs' , - local_info ) end if end subroutine pure subroutine mfi_chetrf ( a , uplo , ipiv , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) integer , intent ( out ), optional , target :: ipiv (:) integer , pointer :: local_ipiv (:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , lwork , allocation_status , deallocation_status complex ( wp ), target :: s_work ( 1 ) complex ( wp ), pointer :: work (:) if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) allocation_status = 0 if ( present ( ipiv )) then local_ipiv => ipiv else allocate ( local_ipiv ( n ), stat = allocation_status ) end if lwork = - 1 call chetrf ( local_uplo , n , a , lda , local_ipiv , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) 404 continue if (. not . present ( ipiv )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'chetrf' , - local_info ) end if end subroutine pure subroutine mfi_zhetrf ( a , uplo , ipiv , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) integer , intent ( out ), optional , target :: ipiv (:) integer , pointer :: local_ipiv (:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , lwork , allocation_status , deallocation_status complex ( wp ), target :: s_work ( 1 ) complex ( wp ), pointer :: work (:) if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) allocation_status = 0 if ( present ( ipiv )) then local_ipiv => ipiv else allocate ( local_ipiv ( n ), stat = allocation_status ) end if lwork = - 1 call zhetrf ( local_uplo , n , a , lda , local_ipiv , s_work , lwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) 404 continue if (. not . present ( ipiv )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zhetrf' , - local_info ) end if end subroutine pure subroutine mfi_chegv ( a , b , w , itype , jobz , uplo , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) real ( wp ), intent ( out ) :: w (:) integer , intent ( in ), optional :: itype integer :: local_itype character , intent ( in ), optional :: jobz character :: local_jobz character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info complex ( wp ), pointer :: work (:) real ( wp ), pointer :: rwork (:) complex ( wp ) :: s_work ( 1 ) integer :: n , lda , ldb , lwork , allocation_status , deallocation_status if ( present ( itype )) then local_itype = itype else local_itype = 1 end if if ( present ( jobz )) then local_jobz = jobz else local_jobz = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) allocation_status = 0 allocate ( rwork ( max ( 1 , 3 * N - 2 )), stat = allocation_status ) lwork = - 1 call chegv ( local_itype , local_jobz , local_uplo , n , a , lda , b , ldb , w , s_work , lwork , rwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call chegv ( local_itype , local_jobz , local_uplo , n , a , lda , b , ldb , w , work , lwork , rwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) 404 continue deallocate ( rwork , stat = deallocation_status ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'chegv' , - local_info ) end if end subroutine pure subroutine mfi_zhegv ( a , b , w , itype , jobz , uplo , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) real ( wp ), intent ( out ) :: w (:) integer , intent ( in ), optional :: itype integer :: local_itype character , intent ( in ), optional :: jobz character :: local_jobz character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info complex ( wp ), pointer :: work (:) real ( wp ), pointer :: rwork (:) complex ( wp ) :: s_work ( 1 ) integer :: n , lda , ldb , lwork , allocation_status , deallocation_status if ( present ( itype )) then local_itype = itype else local_itype = 1 end if if ( present ( jobz )) then local_jobz = jobz else local_jobz = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) allocation_status = 0 allocate ( rwork ( max ( 1 , 3 * N - 2 )), stat = allocation_status ) lwork = - 1 call zhegv ( local_itype , local_jobz , local_uplo , n , a , lda , b , ldb , w , s_work , lwork , rwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) if ( allocation_status == 0 ) then allocate ( work ( lwork ), stat = allocation_status ) end if if ( allocation_status == 0 ) then call zhegv ( local_itype , local_jobz , local_uplo , n , a , lda , b , ldb , w , work , lwork , rwork , local_info ) else local_info = - 1000 end if deallocate ( work , stat = deallocation_status ) 404 continue deallocate ( rwork , stat = deallocation_status ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zhegv' , - local_info ) end if end subroutine pure subroutine mfi_cheevd ( a , w , jobz , uplo , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ) :: w (:) integer , intent ( out ), optional :: info integer :: local_info character , intent ( in ), optional :: jobz character :: local_jobz character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), pointer :: work (:) real ( wp ), pointer :: rwork (:) integer , pointer :: iwork (:) complex ( wp ) :: s_work ( 1 ) real ( wp ) :: s_rwork ( 1 ) integer :: s_iwork ( 1 ) integer :: n , lda , lwork , lrwork , liwork , allocation_status , deallocation_status if ( present ( jobz )) then local_jobz = jobz else local_jobz = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) allocation_status = 0 lwork = - 1 lrwork = - 1 liwork = - 1 call cheevd ( local_jobz , local_uplo , n , a , lda , w , & s_work , lwork , s_rwork , lrwork , s_iwork , liwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) lrwork = int ( s_rwork ( 1 )) liwork = int ( s_iwork ( 1 )) allocate ( iwork ( liwork ), stat = allocation_status ) if ( allocation_status == 0 ) then allocate ( rwork ( lrwork ), stat = allocation_status ) allocate ( work ( lwork ), stat = allocation_status ) call cheevd ( local_jobz , local_uplo , n , a , lda , w , & work , lwork , rwork , lrwork , iwork , liwork , local_info ) else local_info = - 1000 end if deallocate ( iwork , stat = deallocation_status ) deallocate ( rwork , stat = deallocation_status ) deallocate ( work , stat = deallocation_status ) 404 continue if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cheevd' , - local_info ) end if end subroutine pure subroutine mfi_zheevd ( a , w , jobz , uplo , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ) :: w (:) integer , intent ( out ), optional :: info integer :: local_info character , intent ( in ), optional :: jobz character :: local_jobz character , intent ( in ), optional :: uplo character :: local_uplo complex ( wp ), pointer :: work (:) real ( wp ), pointer :: rwork (:) integer , pointer :: iwork (:) complex ( wp ) :: s_work ( 1 ) real ( wp ) :: s_rwork ( 1 ) integer :: s_iwork ( 1 ) integer :: n , lda , lwork , lrwork , liwork , allocation_status , deallocation_status if ( present ( jobz )) then local_jobz = jobz else local_jobz = 'N' end if if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) allocation_status = 0 lwork = - 1 lrwork = - 1 liwork = - 1 call zheevd ( local_jobz , local_uplo , n , a , lda , w , & s_work , lwork , s_rwork , lrwork , s_iwork , liwork , local_info ) if ( local_info /= 0 ) goto 404 lwork = int ( s_work ( 1 )) lrwork = int ( s_rwork ( 1 )) liwork = int ( s_iwork ( 1 )) allocate ( iwork ( liwork ), stat = allocation_status ) if ( allocation_status == 0 ) then allocate ( rwork ( lrwork ), stat = allocation_status ) allocate ( work ( lwork ), stat = allocation_status ) call zheevd ( local_jobz , local_uplo , n , a , lda , w , & work , lwork , rwork , lrwork , iwork , liwork , local_info ) else local_info = - 1000 end if deallocate ( iwork , stat = deallocation_status ) deallocate ( rwork , stat = deallocation_status ) deallocate ( work , stat = deallocation_status ) 404 continue if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zheevd' , - local_info ) end if end subroutine pure subroutine mfi_sgesvd ( a , s , u , vt , ww , job , info ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ) :: s (:) real ( wp ), intent ( out ), optional , target :: u (:,:), vt (:,:) real ( wp ), intent ( out ), optional , target :: ww (:) character , intent ( in ), optional :: job character :: local_job integer , intent ( out ), optional :: info integer :: local_info character :: jobu , jobvt integer :: m , n , lda , ldu , ldvt , lwork , allocation_status , deallocation_status real ( wp ), target :: s_work ( 1 ), l_a2 ( 1 , 1 ) real ( wp ), pointer :: local_u (:,:), local_vt (:,:), work (:) if ( present ( job )) then local_job = job else local_job = 'N' end if lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) if ( present ( u )) then ldu = max ( 1 , size ( u , 1 )) else ldu = 1 end if if ( present ( vt )) then ldvt = max ( 1 , size ( vt , 1 )) else ldvt = 1 end if if ( present ( u )) then if ( size ( u , 2 ) == m ) then jobu = 'A' else jobu = 'S' end if local_u => u else if ( local_job == 'u' . or . local_job == 'U' ) then jobu = 'O' else jobu = 'N' end if local_u => l_a2 end if if ( present ( vt )) then if ( size ( vt , 1 ) == n ) then jobvt = 'A' else jobvt = 'S' end if local_vt => vt else if ( local_job == 'v' . or . local_job == 'V' ) then jobvt = 'O' else jobvt = 'N' end if local_vt => l_a2 end if allocation_status = 0 lwork = - 1 call sgesvd ( jobu , jobvt , m , n , a , lda , s , local_u , ldu , local_vt , ldvt , s_work , lwork , local_info ) if ( local_info /= 0 ) then goto 404 end if lwork = int ( s_work ( 1 )) allocate ( work ( lwork ), stat = allocation_status ) if ( allocation_status == 0 ) then call sgesvd ( jobu , jobvt , m , n , a , lda , s , local_u , ldu , local_vt , ldvt , work , lwork , local_info ) else local_info = - 1000 end if if ( present ( ww )) then ww = real ( work ( 2 : min ( m , n ) - 1 )) end if deallocate ( work , stat = deallocation_status ) 404 continue if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'sgesvd' , - local_info ) end if end subroutine pure subroutine mfi_dgesvd ( a , s , u , vt , ww , job , info ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ) :: s (:) real ( wp ), intent ( out ), optional , target :: u (:,:), vt (:,:) real ( wp ), intent ( out ), optional , target :: ww (:) character , intent ( in ), optional :: job character :: local_job integer , intent ( out ), optional :: info integer :: local_info character :: jobu , jobvt integer :: m , n , lda , ldu , ldvt , lwork , allocation_status , deallocation_status real ( wp ), target :: s_work ( 1 ), l_a2 ( 1 , 1 ) real ( wp ), pointer :: local_u (:,:), local_vt (:,:), work (:) if ( present ( job )) then local_job = job else local_job = 'N' end if lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) if ( present ( u )) then ldu = max ( 1 , size ( u , 1 )) else ldu = 1 end if if ( present ( vt )) then ldvt = max ( 1 , size ( vt , 1 )) else ldvt = 1 end if if ( present ( u )) then if ( size ( u , 2 ) == m ) then jobu = 'A' else jobu = 'S' end if local_u => u else if ( local_job == 'u' . or . local_job == 'U' ) then jobu = 'O' else jobu = 'N' end if local_u => l_a2 end if if ( present ( vt )) then if ( size ( vt , 1 ) == n ) then jobvt = 'A' else jobvt = 'S' end if local_vt => vt else if ( local_job == 'v' . or . local_job == 'V' ) then jobvt = 'O' else jobvt = 'N' end if local_vt => l_a2 end if allocation_status = 0 lwork = - 1 call dgesvd ( jobu , jobvt , m , n , a , lda , s , local_u , ldu , local_vt , ldvt , s_work , lwork , local_info ) if ( local_info /= 0 ) then goto 404 end if lwork = int ( s_work ( 1 )) allocate ( work ( lwork ), stat = allocation_status ) if ( allocation_status == 0 ) then call dgesvd ( jobu , jobvt , m , n , a , lda , s , local_u , ldu , local_vt , ldvt , work , lwork , local_info ) else local_info = - 1000 end if if ( present ( ww )) then ww = real ( work ( 2 : min ( m , n ) - 1 )) end if deallocate ( work , stat = deallocation_status ) 404 continue if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'dgesvd' , - local_info ) end if end subroutine pure subroutine mfi_cgesvd ( a , s , u , vt , ww , job , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ) :: s (:) complex ( wp ), intent ( out ), optional , target :: u (:,:), vt (:,:) real ( wp ), intent ( out ), optional , target :: ww (:) character , intent ( in ), optional :: job character :: local_job integer , intent ( out ), optional :: info integer :: local_info character :: jobu , jobvt integer :: m , n , lda , ldu , ldvt , lwork , allocation_status , deallocation_status complex ( wp ), target :: s_work ( 1 ), l_a2 ( 1 , 1 ) complex ( wp ), pointer :: local_u (:,:), local_vt (:,:), work (:) real ( wp ), pointer :: rwork (:) if ( present ( job )) then local_job = job else local_job = 'N' end if lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) if ( present ( u )) then ldu = max ( 1 , size ( u , 1 )) else ldu = 1 end if if ( present ( vt )) then ldvt = max ( 1 , size ( vt , 1 )) else ldvt = 1 end if if ( present ( u )) then if ( size ( u , 2 ) == m ) then jobu = 'A' else jobu = 'S' end if local_u => u else if ( local_job == 'u' . or . local_job == 'U' ) then jobu = 'O' else jobu = 'N' end if local_u => l_a2 end if if ( present ( vt )) then if ( size ( vt , 1 ) == n ) then jobvt = 'A' else jobvt = 'S' end if local_vt => vt else if ( local_job == 'v' . or . local_job == 'V' ) then jobvt = 'O' else jobvt = 'N' end if local_vt => l_a2 end if allocation_status = 0 lwork = - 1 allocate ( rwork ( 5 * min ( m , n )), stat = allocation_status ) call cgesvd ( jobu , jobvt , m , n , a , lda , s , local_u , ldu , local_vt , ldvt , s_work , lwork , rwork , local_info ) if ( local_info /= 0 ) then goto 404 end if lwork = int ( s_work ( 1 )) allocate ( work ( lwork ), stat = allocation_status ) if ( allocation_status == 0 ) then call cgesvd ( jobu , jobvt , m , n , a , lda , s , local_u , ldu , local_vt , ldvt , work , lwork , rwork , local_info ) else local_info = - 1000 end if if ( present ( ww )) then ww = real ( work ( 2 : min ( m , n ) - 1 )) end if deallocate ( work , stat = deallocation_status ) 404 continue deallocate ( rwork , stat = deallocation_status ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cgesvd' , - local_info ) end if end subroutine pure subroutine mfi_zgesvd ( a , s , u , vt , ww , job , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( out ) :: s (:) complex ( wp ), intent ( out ), optional , target :: u (:,:), vt (:,:) real ( wp ), intent ( out ), optional , target :: ww (:) character , intent ( in ), optional :: job character :: local_job integer , intent ( out ), optional :: info integer :: local_info character :: jobu , jobvt integer :: m , n , lda , ldu , ldvt , lwork , allocation_status , deallocation_status complex ( wp ), target :: s_work ( 1 ), l_a2 ( 1 , 1 ) complex ( wp ), pointer :: local_u (:,:), local_vt (:,:), work (:) real ( wp ), pointer :: rwork (:) if ( present ( job )) then local_job = job else local_job = 'N' end if lda = max ( 1 , size ( a , 1 )) m = size ( a , 1 ) n = size ( a , 2 ) if ( present ( u )) then ldu = max ( 1 , size ( u , 1 )) else ldu = 1 end if if ( present ( vt )) then ldvt = max ( 1 , size ( vt , 1 )) else ldvt = 1 end if if ( present ( u )) then if ( size ( u , 2 ) == m ) then jobu = 'A' else jobu = 'S' end if local_u => u else if ( local_job == 'u' . or . local_job == 'U' ) then jobu = 'O' else jobu = 'N' end if local_u => l_a2 end if if ( present ( vt )) then if ( size ( vt , 1 ) == n ) then jobvt = 'A' else jobvt = 'S' end if local_vt => vt else if ( local_job == 'v' . or . local_job == 'V' ) then jobvt = 'O' else jobvt = 'N' end if local_vt => l_a2 end if allocation_status = 0 lwork = - 1 allocate ( rwork ( 5 * min ( m , n )), stat = allocation_status ) call zgesvd ( jobu , jobvt , m , n , a , lda , s , local_u , ldu , local_vt , ldvt , s_work , lwork , rwork , local_info ) if ( local_info /= 0 ) then goto 404 end if lwork = int ( s_work ( 1 )) allocate ( work ( lwork ), stat = allocation_status ) if ( allocation_status == 0 ) then call zgesvd ( jobu , jobvt , m , n , a , lda , s , local_u , ldu , local_vt , ldvt , work , lwork , rwork , local_info ) else local_info = - 1000 end if if ( present ( ww )) then ww = real ( work ( 2 : min ( m , n ) - 1 )) end if deallocate ( work , stat = deallocation_status ) 404 continue deallocate ( rwork , stat = deallocation_status ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zgesvd' , - local_info ) end if end subroutine pure subroutine mfi_spotrf ( a , info , uplo ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call spotrf ( local_uplo , n , a , lda , local_info ) if ( present ( info )) then info = local_info else if ( local_info /= 0 ) then call mfi_error ( 'spotrf' , local_info ) end if end subroutine pure subroutine mfi_dpotrf ( a , info , uplo ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dpotrf ( local_uplo , n , a , lda , local_info ) if ( present ( info )) then info = local_info else if ( local_info /= 0 ) then call mfi_error ( 'dpotrf' , local_info ) end if end subroutine pure subroutine mfi_cpotrf ( a , info , uplo ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call cpotrf ( local_uplo , n , a , lda , local_info ) if ( present ( info )) then info = local_info else if ( local_info /= 0 ) then call mfi_error ( 'cpotrf' , local_info ) end if end subroutine pure subroutine mfi_zpotrf ( a , info , uplo ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call zpotrf ( local_uplo , n , a , lda , local_info ) if ( present ( info )) then info = local_info else if ( local_info /= 0 ) then call mfi_error ( 'zpotrf' , local_info ) end if end subroutine pure subroutine mfi_spotri ( a , info , uplo ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call spotri ( local_uplo , n , a , lda , local_info ) if ( present ( info )) then info = local_info else if ( local_info /= 0 ) then call mfi_error ( 'spotri' , local_info ) end if end subroutine pure subroutine mfi_dpotri ( a , info , uplo ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call dpotri ( local_uplo , n , a , lda , local_info ) if ( present ( info )) then info = local_info else if ( local_info /= 0 ) then call mfi_error ( 'dpotri' , local_info ) end if end subroutine pure subroutine mfi_cpotri ( a , info , uplo ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call cpotri ( local_uplo , n , a , lda , local_info ) if ( present ( info )) then info = local_info else if ( local_info /= 0 ) then call mfi_error ( 'cpotri' , local_info ) end if end subroutine pure subroutine mfi_zpotri ( a , info , uplo ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) call zpotri ( local_uplo , n , a , lda , local_info ) if ( present ( info )) then info = local_info else if ( local_info /= 0 ) then call mfi_error ( 'zpotri' , local_info ) end if end subroutine pure subroutine mfi_spotrs ( a , b , uplo , info ) integer , parameter :: wp = REAL32 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , nrhs , lda , ldb if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) nrhs = size ( b , 2 ) call spotrs ( local_uplo , n , nrhs , a , lda , b , ldb , local_info ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'spotrs' , - local_info ) end if end subroutine pure subroutine mfi_dpotrs ( a , b , uplo , info ) integer , parameter :: wp = REAL64 real ( wp ), intent ( in ) :: a (:,:) real ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , nrhs , lda , ldb if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) nrhs = size ( b , 2 ) call dpotrs ( local_uplo , n , nrhs , a , lda , b , ldb , local_info ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'dpotrs' , - local_info ) end if end subroutine pure subroutine mfi_cpotrs ( a , b , uplo , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , nrhs , lda , ldb if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) nrhs = size ( b , 2 ) call cpotrs ( local_uplo , n , nrhs , a , lda , b , ldb , local_info ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cpotrs' , - local_info ) end if end subroutine pure subroutine mfi_zpotrs ( a , b , uplo , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( in ) :: a (:,:) complex ( wp ), intent ( inout ) :: b (:,:) character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , nrhs , lda , ldb if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) ldb = max ( 1 , size ( b , 1 )) n = size ( a , 2 ) nrhs = size ( b , 2 ) call zpotrs ( local_uplo , n , nrhs , a , lda , b , ldb , local_info ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zpotrs' , - local_info ) end if end subroutine !> Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF pure subroutine mfi_spocon ( a , anorm , rcond , uplo , info ) integer , parameter :: wp = REAL32 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( in ) :: anorm real ( wp ), intent ( out ) :: rcond character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , allocation_status , deallocation_status real ( wp ), pointer :: work (:) integer , pointer :: xwork (:) if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) allocation_status = 0 allocate ( xwork ( n ), stat = allocation_status ) if ( allocation_status == 0 ) allocate ( work ( 3 * n ), stat = allocation_status ) if ( allocation_status == 0 ) then call spocon ( local_uplo , n , a , lda , anorm , rcond , work , xwork , local_info ) else local_info = - 1000 end if deallocate ( xwork , stat = deallocation_status ) deallocate ( work , stat = deallocation_status ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'spocon' , - local_info ) end if end subroutine !> Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF pure subroutine mfi_dpocon ( a , anorm , rcond , uplo , info ) integer , parameter :: wp = REAL64 real ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( in ) :: anorm real ( wp ), intent ( out ) :: rcond character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , allocation_status , deallocation_status real ( wp ), pointer :: work (:) integer , pointer :: xwork (:) if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) allocation_status = 0 allocate ( xwork ( n ), stat = allocation_status ) if ( allocation_status == 0 ) allocate ( work ( 3 * n ), stat = allocation_status ) if ( allocation_status == 0 ) then call dpocon ( local_uplo , n , a , lda , anorm , rcond , work , xwork , local_info ) else local_info = - 1000 end if deallocate ( xwork , stat = deallocation_status ) deallocate ( work , stat = deallocation_status ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'dpocon' , - local_info ) end if end subroutine !> Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF pure subroutine mfi_cpocon ( a , anorm , rcond , uplo , info ) integer , parameter :: wp = REAL32 complex ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( in ) :: anorm real ( wp ), intent ( out ) :: rcond character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , allocation_status , deallocation_status complex ( wp ), pointer :: work (:) real ( wp ), pointer :: xwork (:) if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) allocation_status = 0 allocate ( xwork ( n ), stat = allocation_status ) if ( allocation_status == 0 ) allocate ( work ( 3 * n ), stat = allocation_status ) if ( allocation_status == 0 ) then call cpocon ( local_uplo , n , a , lda , anorm , rcond , work , xwork , local_info ) else local_info = - 1000 end if deallocate ( xwork , stat = deallocation_status ) deallocate ( work , stat = deallocation_status ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'cpocon' , - local_info ) end if end subroutine !> Estimates the reciprocal of the condition number of a real symmetric / complex Hermitian positive definite matrix using the Cholesky factorization computed by ?POTRF pure subroutine mfi_zpocon ( a , anorm , rcond , uplo , info ) integer , parameter :: wp = REAL64 complex ( wp ), intent ( inout ) :: a (:,:) real ( wp ), intent ( in ) :: anorm real ( wp ), intent ( out ) :: rcond character , intent ( in ), optional :: uplo character :: local_uplo integer , intent ( out ), optional :: info integer :: local_info integer :: n , lda , allocation_status , deallocation_status complex ( wp ), pointer :: work (:) real ( wp ), pointer :: xwork (:) if ( present ( uplo )) then local_uplo = uplo else local_uplo = 'U' end if lda = max ( 1 , size ( a , 1 )) n = size ( a , 2 ) allocation_status = 0 allocate ( xwork ( n ), stat = allocation_status ) if ( allocation_status == 0 ) allocate ( work ( 3 * n ), stat = allocation_status ) if ( allocation_status == 0 ) then call zpocon ( local_uplo , n , a , lda , anorm , rcond , work , xwork , local_info ) else local_info = - 1000 end if deallocate ( xwork , stat = deallocation_status ) deallocate ( work , stat = deallocation_status ) if ( present ( info )) then info = local_info else if ( local_info <= - 1000 ) then call mfi_error ( 'zpocon' , - local_info ) end if end subroutine pure subroutine mfi_error ( name , info ) character ( * ), intent ( in ) :: name integer , intent ( in ) :: info call f77_xerbla ( name , info ) end subroutine end module","tags":"","loc":"sourcefile/lapack.f90~2.html"}]}